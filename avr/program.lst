   1               		.file	"program.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  11               	lcd_write:
  12               	.LFB11:
  13               		.file 1 "./lcd.h"
   1:./lcd.h       **** /**************************************************************
   2:./lcd.h       ****  *	Hitachi HD44780 LCD routines for AVR
   3:./lcd.h       ****  *						-Er.Sapin Bajracharya, October 2012
   4:./lcd.h       ****  *                      -edit by Rabin Giri
   5:./lcd.h       ****  **************************************************************
   6:./lcd.h       ****  *	The DDR bits associated with the various lines
   7:./lcd.h       ****  *	(LCD_EN, LCD_RS, LCD_D7..LCD_D0, LCD_DATA, LCD_CLK)
   8:./lcd.h       ****  *	must be set (output mode) in the main program
   9:./lcd.h       ****  *	prior to calling the lcd_init() function.
  10:./lcd.h       ****  **************************************************************
  11:./lcd.h       ****  *		Uses 6 lines:
  12:./lcd.h       ****  *		LCD_EN		:	STROBE 			:	Strobe for LCD/LCD_EN
  13:./lcd.h       ****  *		LCD_RS		:	RegisterSelect	:	R/S line
  14:./lcd.h       ****  *		LCD_D7...D4	:	Data lines		:	D7 to D4 lines
  15:./lcd.h       ****  **************************************************************
  16:./lcd.h       **** 
  17:./lcd.h       **** 	Available functions:
  18:./lcd.h       **** 	lcd_init();
  19:./lcd.h       **** 		LCD initialization function
  20:./lcd.h       **** 		MUST be called first, after associated DDR bits
  21:./lcd.h       **** 		have been configured as outputs
  22:./lcd.h       **** 	lcd_putch(char c);
  23:./lcd.h       **** 		Displays supplied character at the current position
  24:./lcd.h       **** 	lcd_puts(const char *s);
  25:./lcd.h       **** 		Displays supplied string(character array) starting
  26:./lcd.h       **** 		at current position
  27:./lcd.h       **** 	lcd_clear();
  28:./lcd.h       **** 		Clears and homes the display
  29:./lcd.h       **** 	lcd_goto(uint8_t pos)
  30:./lcd.h       **** 		Sets cursor location to given address (0-127)
  31:./lcd.h       **** 	lcd_unum(uint16_t num)
  32:./lcd.h       **** 		Displays unsigned integer (0 - 65535)
  33:./lcd.h       **** 	lcd_unum3(uint16_t num)
  34:./lcd.h       **** 		Displays unsigned number, upto 3 digits(0-999)
  35:./lcd.h       **** 	lcd_unum_hex(uint16_t num)
  36:./lcd.h       **** 		Displays 16bit number in 4digit Hex
  37:./lcd.h       **** 	lcd_cmd(uint8_t c);
  38:./lcd.h       **** 		Writes supplied byte to LCD with RS = 0 (command)
  39:./lcd.h       **** 	lcd_dat(uint8_t c);
  40:./lcd.h       **** 		Writes supplied byte to LCD with RS = 1 (data)
  41:./lcd.h       ****  *************************************************************/
  42:./lcd.h       **** #ifndef F_CPU
  43:./lcd.h       **** #define F_CPU 1000000UL
  44:./lcd.h       **** #endif
  45:./lcd.h       **** 
  46:./lcd.h       **** //
  47:./lcd.h       **** #define LCD_EN_PORT	PORTA
  48:./lcd.h       **** #define LCD_EN_PIN 1//2,5
  49:./lcd.h       **** 
  50:./lcd.h       **** #define	LCD_RS_PORT PORTA		//R/S line
  51:./lcd.h       **** #define	LCD_RS_PIN	0//3,6
  52:./lcd.h       **** 
  53:./lcd.h       **** #define LCD_D7_PORT PORTA
  54:./lcd.h       **** #define LCD_D7_PIN	5//7,1
  55:./lcd.h       **** #define LCD_D6_PORT PORTA
  56:./lcd.h       **** #define LCD_D6_PIN	4 //6,2
  57:./lcd.h       **** #define LCD_D5_PORT PORTA
  58:./lcd.h       **** #define LCD_D5_PIN	3  //5,3
  59:./lcd.h       **** #define LCD_D4_PORT PORTA
  60:./lcd.h       **** #define LCD_D4_PIN	2  //4,4
  61:./lcd.h       **** 
  62:./lcd.h       **** 
  63:./lcd.h       **** 
  64:./lcd.h       **** /*************************************************/
  65:./lcd.h       **** /*****DO NOT MODIFY ANYTHING BELOW THIS POINT*****/
  66:./lcd.h       **** /*************************************************/
  67:./lcd.h       **** 
  68:./lcd.h       **** 
  69:./lcd.h       **** #include <util/delay.h>
  70:./lcd.h       **** 
  71:./lcd.h       **** #include <avr/pgmspace.h>
  72:./lcd.h       **** 
  73:./lcd.h       **** #include <stdarg.h>
  74:./lcd.h       **** #include <stdlib.h>
  75:./lcd.h       **** 
  76:./lcd.h       **** 
  77:./lcd.h       **** #define DDR(x) (*(&x - 1))      /* address of data direction register of port x */
  78:./lcd.h       **** 
  79:./lcd.h       **** /* instruction register bit positions, see HD44780U data sheet */
  80:./lcd.h       **** #define LCD_CLR               0      /* DB0: clear display                  */
  81:./lcd.h       **** 
  82:./lcd.h       **** #define LCD_HOME              1      /* DB1: return to home position        */
  83:./lcd.h       **** 
  84:./lcd.h       **** #define LCD_ENTRY_MODE        2      /* DB2: set entry mode                 */
  85:./lcd.h       **** #define LCD_ENTRY_INC         1      /*   DB1: 1=increment, 0=decrement     */
  86:./lcd.h       **** #define LCD_ENTRY_SHIFT       0      /*   DB2: 1=display shift on           */
  87:./lcd.h       **** 
  88:./lcd.h       **** #define LCD_ON                3      /* DB3: turn lcd/cursor on             */
  89:./lcd.h       **** #define LCD_ON_DISPLAY        2      /*   DB2: turn display on              */
  90:./lcd.h       **** #define LCD_ON_CURSOR         1      /*   DB1: turn cursor on               */
  91:./lcd.h       **** #define LCD_ON_BLINK          0      /*     DB0: blinking cursor ?          */
  92:./lcd.h       **** 
  93:./lcd.h       **** #define LCD_MOVE              4      /* DB4: move cursor/display            */
  94:./lcd.h       **** #define LCD_MOVE_DISP         3      /*   DB3: move display (0-> cursor) ?  */
  95:./lcd.h       **** #define LCD_MOVE_RIGHT        2      /*   DB2: move right (0-> left) ?      */
  96:./lcd.h       **** 
  97:./lcd.h       **** #define LCD_FUNCTION          5      /* DB5: function set                   */
  98:./lcd.h       **** #define LCD_FUNCTION_8BIT     4      /*   DB4: set 8BIT mode (0->4BIT mode) */
  99:./lcd.h       **** #define LCD_FUNCTION_2LINES   3      /*   DB3: two lines (0->one line)      */
 100:./lcd.h       **** #define LCD_FUNCTION_10DOTS   2      /*   DB2: 5x10 font (0->5x7 font)      */
 101:./lcd.h       **** 
 102:./lcd.h       **** #define LCD_CGRAM             6      /* DB6: set CG RAM address             */
 103:./lcd.h       **** 
 104:./lcd.h       **** #define LCD_DDRAM             7      /* DB7: set DD RAM address             */
 105:./lcd.h       **** 
 106:./lcd.h       **** #define LCD_BUSY              7      /* DB7: LCD is busy                    */
 107:./lcd.h       **** 
 108:./lcd.h       **** /* set entry mode: display shift on/off, dec/inc cursor move direction */
 109:./lcd.h       **** #define LCD_ENTRY_DEC            0x04   /* display shift off, dec cursor move dir */ //((1<<LCD_ENT
 110:./lcd.h       **** #define LCD_ENTRY_DEC_SHIFT      0x05   /* display shift on,  dec cursor move dir */ //((1<<LCD_ENT
 111:./lcd.h       **** #define LCD_ENTRY_INC_           0x06   /* display shift off, inc cursor move dir */ //((1<<LCD_ENT
 112:./lcd.h       **** #define LCD_ENTRY_INC_SHIFT      0x07   /* display shift on,  inc cursor move dir */ //((1<<LCD_ENT
 113:./lcd.h       **** 
 114:./lcd.h       **** /* display on/off, cursor on/off, blinking char at cursor position */
 115:./lcd.h       **** #define LCD_DISP_OFF             0x08   /* display off                            */ //((1<<LCD_ON)
 116:./lcd.h       **** #define LCD_DISP_ON              0x0C   /* display on, cursor off                 */ //((1<<LCD_ON)
 117:./lcd.h       **** #define LCD_DISP_ON_BLINK        0x0D   /* display on, cursor off, blink char     */ //((1<<LCD_ON)
 118:./lcd.h       **** #define LCD_DISP_ON_CURSOR       0x0E   /* display on, cursor on                  */ //((1<<LCD_ON)
 119:./lcd.h       **** #define LCD_DISP_ON_CURSOR_BLINK 0x0F   /* display on, cursor on, blink char      */ //((1<<LCD_ON)
 120:./lcd.h       **** 
 121:./lcd.h       **** /* move cursor/shift display */
 122:./lcd.h       **** #define LCD_MOVE_CURSOR_LEFT     0x10   /* move cursor left  (decrement)          */ //((1<<LCD_MOV
 123:./lcd.h       **** #define LCD_MOVE_CURSOR_RIGHT    0x14   /* move cursor right (increment)          */ //((1<<LCD_MOV
 124:./lcd.h       **** #define LCD_MOVE_DISP_LEFT       0x18   /* shift display left                     */ //((1<<LCD_MOV
 125:./lcd.h       **** #define LCD_MOVE_DISP_RIGHT      0x1C   /* shift display right                    */ //((1<<LCD_MOV
 126:./lcd.h       **** 
 127:./lcd.h       **** /* function set: set interface data length and number of display lines */
 128:./lcd.h       **** #define LCD_FUNCTION_4BIT_1LINE  0x20   /* 4-bit interface, single line, 5x7 dots */ //((1<<LCD_FUN
 129:./lcd.h       **** #define LCD_FUNCTION_4BIT_2LINES 0x28   /* 4-bit interface, dual line,   5x7 dots */ //((1<<LCD_FUN
 130:./lcd.h       **** #define LCD_FUNCTION_8BIT_1LINE  0x30   /* 8-bit interface, single line, 5x7 dots */ //((1<<LCD_FUN
 131:./lcd.h       **** #define LCD_FUNCTION_8BIT_2LINES 0x38   /* 8-bit interface, dual line,   5x7 dots */ //((1<<LCD_FUN
 132:./lcd.h       **** 
 133:./lcd.h       **** 
 134:./lcd.h       **** #define LCD_MODE_DEFAULT     ((1<<LCD_ENTRY_MODE) | (1<<LCD_ENTRY_INC) )
 135:./lcd.h       **** 
 136:./lcd.h       **** 
 137:./lcd.h       **** #define	LCD_STROBE()	((LCD_EN_PORT |= (1 << LCD_EN_PIN)),(LCD_EN_PORT &= ~(1 << LCD_EN_PIN)))
 138:./lcd.h       **** 
 139:./lcd.h       **** 
 140:./lcd.h       **** 
 141:./lcd.h       **** 
 142:./lcd.h       **** static void lcd_write(uint8_t c)
 143:./lcd.h       **** {
  14               		.loc 1 143 0
  15               		.cfi_startproc
  16               	.LVL0:
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
  21               	.LBB22:
  22               	.LBB23:
  23               		.file 2 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/lib/avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/lib/avr/include/util/delay.h **** #endif
  41:/usr/lib/avr/include/util/delay.h **** 
  42:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  45:/usr/lib/avr/include/util/delay.h **** 
  46:/usr/lib/avr/include/util/delay.h **** /** \file */
  47:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/lib/avr/include/util/delay.h ****     \code
  49:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/lib/avr/include/util/delay.h ****     \endcode
  53:/usr/lib/avr/include/util/delay.h **** 
  54:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/lib/avr/include/util/delay.h ****     used.
  58:/usr/lib/avr/include/util/delay.h **** 
  59:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/lib/avr/include/util/delay.h **** 
  68:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/lib/avr/include/util/delay.h **** 
  77:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/lib/avr/include/util/delay.h **** 
  81:/usr/lib/avr/include/util/delay.h **** */
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/lib/avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/lib/avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/lib/avr/include/util/delay.h **** #endif
  87:/usr/lib/avr/include/util/delay.h **** 
  88:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/lib/avr/include/util/delay.h **** #endif
  93:/usr/lib/avr/include/util/delay.h **** 
  94:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/lib/avr/include/util/delay.h **** #endif
  97:/usr/lib/avr/include/util/delay.h **** 
  98:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 102:/usr/lib/avr/include/util/delay.h **** #endif
 103:/usr/lib/avr/include/util/delay.h **** 
 104:/usr/lib/avr/include/util/delay.h **** /**
 105:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/lib/avr/include/util/delay.h **** 
 107:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/lib/avr/include/util/delay.h **** 
 109:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/lib/avr/include/util/delay.h **** 
 112:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/lib/avr/include/util/delay.h **** 
 114:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/lib/avr/include/util/delay.h **** 
 120:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/lib/avr/include/util/delay.h **** 
 125:/usr/lib/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/lib/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/lib/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/lib/avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/lib/avr/include/util/delay.h **** 
 132:/usr/lib/avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/lib/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/lib/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/lib/avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/lib/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/lib/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/lib/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/lib/avr/include/util/delay.h **** 
 140:/usr/lib/avr/include/util/delay.h ****  */
 141:/usr/lib/avr/include/util/delay.h **** void
 142:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/lib/avr/include/util/delay.h **** {
 144:/usr/lib/avr/include/util/delay.h **** 	double __tmp ; 
 145:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 146:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 147:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 148:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 149:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 150:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 153:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 154:/usr/lib/avr/include/util/delay.h **** 
 155:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 156:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 157:/usr/lib/avr/include/util/delay.h **** 
 158:/usr/lib/avr/include/util/delay.h **** 	#else
 159:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 160:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 161:/usr/lib/avr/include/util/delay.h **** 	#endif
 162:/usr/lib/avr/include/util/delay.h **** 
 163:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 164:/usr/lib/avr/include/util/delay.h **** 
 165:/usr/lib/avr/include/util/delay.h **** #else
 166:/usr/lib/avr/include/util/delay.h **** 	uint16_t __ticks;
 167:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 168:/usr/lib/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 169:/usr/lib/avr/include/util/delay.h **** 		__ticks = 1;
 170:/usr/lib/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 171:/usr/lib/avr/include/util/delay.h **** 	{
 172:/usr/lib/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 173:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 174:/usr/lib/avr/include/util/delay.h **** 		while(__ticks)
 175:/usr/lib/avr/include/util/delay.h **** 		{
 176:/usr/lib/avr/include/util/delay.h **** 			// wait 1/10 ms
 177:/usr/lib/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 178:/usr/lib/avr/include/util/delay.h **** 			__ticks --;
 179:/usr/lib/avr/include/util/delay.h **** 		}
 180:/usr/lib/avr/include/util/delay.h **** 		return;
 181:/usr/lib/avr/include/util/delay.h **** 	}
 182:/usr/lib/avr/include/util/delay.h **** 	else
 183:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 184:/usr/lib/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 185:/usr/lib/avr/include/util/delay.h **** #endif
 186:/usr/lib/avr/include/util/delay.h **** }
 187:/usr/lib/avr/include/util/delay.h **** 
 188:/usr/lib/avr/include/util/delay.h **** /**
 189:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 190:/usr/lib/avr/include/util/delay.h **** 
 191:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 192:/usr/lib/avr/include/util/delay.h **** 
 193:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 194:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 195:/usr/lib/avr/include/util/delay.h **** 
 196:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 197:/usr/lib/avr/include/util/delay.h **** 
 198:/usr/lib/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 199:/usr/lib/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 200:/usr/lib/avr/include/util/delay.h ****    will not be informed about this case.
 201:/usr/lib/avr/include/util/delay.h **** 
 202:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 203:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 204:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 205:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0us.
 206:/usr/lib/avr/include/util/delay.h ****   
 207:/usr/lib/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 208:/usr/lib/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 209:/usr/lib/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 210:/usr/lib/avr/include/util/delay.h **** 
 211:/usr/lib/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 212:/usr/lib/avr/include/util/delay.h ****    to round down and round to closest integer.
 213:/usr/lib/avr/include/util/delay.h ****  
 214:/usr/lib/avr/include/util/delay.h ****    Note: The new implementation of _delay_us(double __us) with 
 215:/usr/lib/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible.
 216:/usr/lib/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 217:/usr/lib/avr/include/util/delay.h ****    Also, the backward compatible
 218:/usr/lib/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 219:/usr/lib/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 220:/usr/lib/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 221:/usr/lib/avr/include/util/delay.h **** 
 222:/usr/lib/avr/include/util/delay.h ****  */
 223:/usr/lib/avr/include/util/delay.h **** void
 224:/usr/lib/avr/include/util/delay.h **** _delay_us(double __us)
 225:/usr/lib/avr/include/util/delay.h **** {
 226:/usr/lib/avr/include/util/delay.h **** 	double __tmp ; 
 227:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 228:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 229:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 230:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 231:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 232:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 233:/usr/lib/avr/include/util/delay.h **** 
 234:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 235:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 236:/usr/lib/avr/include/util/delay.h **** 
 237:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 238:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 239:/usr/lib/avr/include/util/delay.h **** 
 240:/usr/lib/avr/include/util/delay.h **** 	#else
 241:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 242:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 243:/usr/lib/avr/include/util/delay.h **** 	#endif
 244:/usr/lib/avr/include/util/delay.h **** 
 245:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
  24               		.loc 2 245 0
  25 0000 95ED      		ldi r25,lo8(-43)
  26 0002 9A95      	1:	dec r25
  27 0004 01F4      		brne 1b
  28 0006 0000      		nop
  29               	.LBE23:
  30               	.LBE22:
 144:./lcd.h       **** 	_delay_us(40);
 145:./lcd.h       **** 	//MS nibble
 146:./lcd.h       **** 	if(c & 0x80)
  31               		.loc 1 146 0
  32 0008 87FF      		sbrs r24,7
  33 000a 00C0      		rjmp .L2
 147:./lcd.h       **** 		LCD_D7_PORT |=  (1 << LCD_D7_PIN);
  34               		.loc 1 147 0
  35 000c DD9A      		sbi 0x1b,5
  36 000e 00C0      		rjmp .L3
  37               	.L2:
 148:./lcd.h       **** 	else
 149:./lcd.h       **** 		LCD_D7_PORT &= ~(1 << LCD_D7_PIN);
  38               		.loc 1 149 0
  39 0010 DD98      		cbi 0x1b,5
  40               	.L3:
 150:./lcd.h       **** 
 151:./lcd.h       **** 	if(c & 0x40)
  41               		.loc 1 151 0
  42 0012 86FF      		sbrs r24,6
  43 0014 00C0      		rjmp .L4
 152:./lcd.h       **** 		LCD_D6_PORT |=  (1 << LCD_D6_PIN);
  44               		.loc 1 152 0
  45 0016 DC9A      		sbi 0x1b,4
  46 0018 00C0      		rjmp .L5
  47               	.L4:
 153:./lcd.h       **** 	else
 154:./lcd.h       **** 		LCD_D6_PORT &= ~(1 << LCD_D6_PIN);
  48               		.loc 1 154 0
  49 001a DC98      		cbi 0x1b,4
  50               	.L5:
 155:./lcd.h       **** 
 156:./lcd.h       **** 	if(c & 0x20)
  51               		.loc 1 156 0
  52 001c 85FF      		sbrs r24,5
  53 001e 00C0      		rjmp .L6
 157:./lcd.h       **** 		LCD_D5_PORT |=  (1 << LCD_D5_PIN);
  54               		.loc 1 157 0
  55 0020 DB9A      		sbi 0x1b,3
  56 0022 00C0      		rjmp .L7
  57               	.L6:
 158:./lcd.h       **** 	else
 159:./lcd.h       **** 		LCD_D5_PORT &= ~(1 << LCD_D5_PIN);
  58               		.loc 1 159 0
  59 0024 DB98      		cbi 0x1b,3
  60               	.L7:
 160:./lcd.h       **** 
 161:./lcd.h       **** 	if(c & 0x10)
  61               		.loc 1 161 0
  62 0026 84FF      		sbrs r24,4
  63 0028 00C0      		rjmp .L8
 162:./lcd.h       **** 		LCD_D4_PORT |=  (1 << LCD_D4_PIN);
  64               		.loc 1 162 0
  65 002a DA9A      		sbi 0x1b,2
  66 002c 00C0      		rjmp .L9
  67               	.L8:
 163:./lcd.h       **** 	else
 164:./lcd.h       **** 		LCD_D4_PORT &= ~(1 << LCD_D4_PIN);
  68               		.loc 1 164 0
  69 002e DA98      		cbi 0x1b,2
  70               	.L9:
 165:./lcd.h       **** 
 166:./lcd.h       **** 	LCD_STROBE();
  71               		.loc 1 166 0
  72 0030 D99A      		sbi 0x1b,1
  73 0032 D998      		cbi 0x1b,1
 167:./lcd.h       **** 
 168:./lcd.h       **** 	//LS nibble
 169:./lcd.h       **** 	if(c & 0x08)
  74               		.loc 1 169 0
  75 0034 83FF      		sbrs r24,3
  76 0036 00C0      		rjmp .L10
 170:./lcd.h       **** 		LCD_D7_PORT |=  (1 << LCD_D7_PIN);
  77               		.loc 1 170 0
  78 0038 DD9A      		sbi 0x1b,5
  79 003a 00C0      		rjmp .L11
  80               	.L10:
 171:./lcd.h       **** 	else
 172:./lcd.h       **** 		LCD_D7_PORT &= ~(1 << LCD_D7_PIN);
  81               		.loc 1 172 0
  82 003c DD98      		cbi 0x1b,5
  83               	.L11:
 173:./lcd.h       **** 
 174:./lcd.h       **** 	if(c & 0x04)
  84               		.loc 1 174 0
  85 003e 82FF      		sbrs r24,2
  86 0040 00C0      		rjmp .L12
 175:./lcd.h       **** 		LCD_D6_PORT |=  (1 << LCD_D6_PIN);
  87               		.loc 1 175 0
  88 0042 DC9A      		sbi 0x1b,4
  89 0044 00C0      		rjmp .L13
  90               	.L12:
 176:./lcd.h       **** 	else
 177:./lcd.h       **** 		LCD_D6_PORT &= ~(1 << LCD_D6_PIN);
  91               		.loc 1 177 0
  92 0046 DC98      		cbi 0x1b,4
  93               	.L13:
 178:./lcd.h       **** 
 179:./lcd.h       **** 	if(c & 0x02)
  94               		.loc 1 179 0
  95 0048 81FF      		sbrs r24,1
  96 004a 00C0      		rjmp .L14
 180:./lcd.h       **** 		LCD_D5_PORT |=  (1 << LCD_D5_PIN);
  97               		.loc 1 180 0
  98 004c DB9A      		sbi 0x1b,3
  99 004e 00C0      		rjmp .L15
 100               	.L14:
 181:./lcd.h       **** 	else
 182:./lcd.h       **** 		LCD_D5_PORT &= ~(1 << LCD_D5_PIN);
 101               		.loc 1 182 0
 102 0050 DB98      		cbi 0x1b,3
 103               	.L15:
 183:./lcd.h       **** 
 184:./lcd.h       **** 	if(c & 0x01)
 104               		.loc 1 184 0
 105 0052 80FF      		sbrs r24,0
 106 0054 00C0      		rjmp .L16
 185:./lcd.h       **** 		LCD_D4_PORT |=  (1 << LCD_D4_PIN);
 107               		.loc 1 185 0
 108 0056 DA9A      		sbi 0x1b,2
 109 0058 00C0      		rjmp .L17
 110               	.L16:
 186:./lcd.h       **** 	else
 187:./lcd.h       **** 		LCD_D4_PORT &= ~(1 << LCD_D4_PIN);
 111               		.loc 1 187 0
 112 005a DA98      		cbi 0x1b,2
 113               	.L17:
 188:./lcd.h       **** 
 189:./lcd.h       **** 	LCD_STROBE();
 114               		.loc 1 189 0
 115 005c D99A      		sbi 0x1b,1
 116 005e D998      		cbi 0x1b,1
 117 0060 0895      		ret
 118               		.cfi_endproc
 119               	.LFE11:
 121               	.global	lcd_cmd
 123               	lcd_cmd:
 124               	.LFB12:
 190:./lcd.h       **** }
 191:./lcd.h       **** 
 192:./lcd.h       **** 
 193:./lcd.h       **** 
 194:./lcd.h       **** 
 195:./lcd.h       **** //Write command to LCD
 196:./lcd.h       **** void lcd_cmd(uint8_t cmd)
 197:./lcd.h       **** {
 125               		.loc 1 197 0
 126               		.cfi_startproc
 127               	.LVL1:
 128               	/* prologue: function */
 129               	/* frame size = 0 */
 130               	/* stack size = 0 */
 131               	.L__stack_usage = 0
 198:./lcd.h       **** 	LCD_RS_PORT &= ~(1 << LCD_RS_PIN);
 132               		.loc 1 198 0
 133 0062 D898      		cbi 0x1b,0
 199:./lcd.h       **** 	lcd_write(cmd);
 134               		.loc 1 199 0
 135 0064 0C94 0000 		jmp lcd_write
 136               	.LVL2:
 137               		.cfi_endproc
 138               	.LFE12:
 140               	.global	lcd_dat
 142               	lcd_dat:
 143               	.LFB13:
 200:./lcd.h       **** }
 201:./lcd.h       **** 
 202:./lcd.h       **** //Write character data to LCD
 203:./lcd.h       **** void lcd_dat(uint8_t dat)
 204:./lcd.h       **** {
 144               		.loc 1 204 0
 145               		.cfi_startproc
 146               	.LVL3:
 147               	/* prologue: function */
 148               	/* frame size = 0 */
 149               	/* stack size = 0 */
 150               	.L__stack_usage = 0
 205:./lcd.h       **** 	LCD_RS_PORT |= (1 << LCD_RS_PIN);
 151               		.loc 1 205 0
 152 0068 D89A      		sbi 0x1b,0
 206:./lcd.h       **** 	lcd_write(dat);
 153               		.loc 1 206 0
 154 006a 0C94 0000 		jmp lcd_write
 155               	.LVL4:
 156               		.cfi_endproc
 157               	.LFE13:
 159               	.global	lcd_clear
 161               	lcd_clear:
 162               	.LFB14:
 207:./lcd.h       **** }
 208:./lcd.h       **** 
 209:./lcd.h       **** 
 210:./lcd.h       **** /*
 211:./lcd.h       ****  * 	Clear and home the LCD
 212:./lcd.h       ****  */
 213:./lcd.h       **** 
 214:./lcd.h       **** void lcd_clear(void)
 215:./lcd.h       **** {
 163               		.loc 1 215 0
 164               		.cfi_startproc
 165               	/* prologue: function */
 166               	/* frame size = 0 */
 167               	/* stack size = 0 */
 168               	.L__stack_usage = 0
 216:./lcd.h       **** 	LCD_RS_PORT &= ~(1 << LCD_RS_PIN);
 169               		.loc 1 216 0
 170 006e D898      		cbi 0x1b,0
 217:./lcd.h       **** 	lcd_write(1<<LCD_CLR);
 171               		.loc 1 217 0
 172 0070 81E0      		ldi r24,lo8(1)
 173 0072 0E94 0000 		call lcd_write
 174               	.LVL5:
 175               	.LBB24:
 176               	.LBB25:
 163:/usr/lib/avr/include/util/delay.h **** 
 177               		.loc 2 163 0
 178 0076 8FE3      		ldi r24,lo8(7999)
 179 0078 9FE1      		ldi r25,hi8(7999)
 180 007a 0197      	1:	sbiw r24,1
 181 007c 01F4      		brne 1b
 182 007e 00C0      		rjmp .
 183 0080 0000      		nop
 184 0082 0895      		ret
 185               	.LBE25:
 186               	.LBE24:
 187               		.cfi_endproc
 188               	.LFE14:
 190               	.global	lcd_puts
 192               	lcd_puts:
 193               	.LFB15:
 218:./lcd.h       **** 	_delay_ms(2);
 219:./lcd.h       **** }
 220:./lcd.h       **** 
 221:./lcd.h       **** /* write a string of chars to the LCD */
 222:./lcd.h       **** 
 223:./lcd.h       **** void lcd_puts(const char * s)
 224:./lcd.h       **** {
 194               		.loc 1 224 0
 195               		.cfi_startproc
 196               	.LVL6:
 197 0084 CF93      		push r28
 198               	.LCFI0:
 199               		.cfi_def_cfa_offset 3
 200               		.cfi_offset 28, -2
 201 0086 DF93      		push r29
 202               	.LCFI1:
 203               		.cfi_def_cfa_offset 4
 204               		.cfi_offset 29, -3
 205               	/* prologue: function */
 206               	/* frame size = 0 */
 207               	/* stack size = 2 */
 208               	.L__stack_usage = 2
 225:./lcd.h       **** 	LCD_RS_PORT |= (1 << LCD_RS_PIN);	// write characters
 209               		.loc 1 225 0
 210 0088 D89A      		sbi 0x1b,0
 211 008a EC01      		movw r28,r24
 212               	.LVL7:
 213               	.L23:
 226:./lcd.h       **** 	while(*s)
 214               		.loc 1 226 0
 215 008c 8991      		ld r24,Y+
 216               	.LVL8:
 217 008e 8823      		tst r24
 218 0090 01F0      		breq .L25
 219               	.LVL9:
 227:./lcd.h       **** 		lcd_write(*s++);
 220               		.loc 1 227 0
 221 0092 0E94 0000 		call lcd_write
 222               	.LVL10:
 223 0096 00C0      		rjmp .L23
 224               	.LVL11:
 225               	.L25:
 226               	/* epilogue start */
 228:./lcd.h       **** }
 227               		.loc 1 228 0
 228 0098 DF91      		pop r29
 229 009a CF91      		pop r28
 230               	.LVL12:
 231 009c 0895      		ret
 232               		.cfi_endproc
 233               	.LFE15:
 235               	.global	lcd_puts_p
 237               	lcd_puts_p:
 238               	.LFB16:
 229:./lcd.h       **** 
 230:./lcd.h       **** #define lcd_puts_P(__s)         lcd_puts_p(PSTR(__s))
 231:./lcd.h       **** 
 232:./lcd.h       **** /* print string from program memory on lcd (no auto linefeed) */
 233:./lcd.h       **** 
 234:./lcd.h       **** void lcd_puts_p(const char *progmem_s)
 235:./lcd.h       **** {
 239               		.loc 1 235 0
 240               		.cfi_startproc
 241               	.LVL13:
 242 009e CF93      		push r28
 243               	.LCFI2:
 244               		.cfi_def_cfa_offset 3
 245               		.cfi_offset 28, -2
 246 00a0 DF93      		push r29
 247               	.LCFI3:
 248               		.cfi_def_cfa_offset 4
 249               		.cfi_offset 29, -3
 250               	/* prologue: function */
 251               	/* frame size = 0 */
 252               	/* stack size = 2 */
 253               	.L__stack_usage = 2
 236:./lcd.h       ****     register char c;
 237:./lcd.h       **** 
 238:./lcd.h       **** 	LCD_RS_PORT |= (1 << LCD_RS_PIN);	// write characters
 254               		.loc 1 238 0
 255 00a2 D89A      		sbi 0x1b,0
 239:./lcd.h       ****     while ( (c = pgm_read_byte(progmem_s++)) )
 256               		.loc 1 239 0
 257 00a4 FC01      		movw r30,r24
 258               	.LVL14:
 259               	.L27:
 260               	.LBB26:
 261               	/* #APP */
 262               	 ;  239 "./lcd.h" 1
 263 00a6 8491      		lpm r24, Z
 264               		
 265               	 ;  0 "" 2
 266               	.LVL15:
 267               	/* #NOAPP */
 268 00a8 EF01      		movw r28,r30
 269 00aa 2196      		adiw r28,1
 270               	.LVL16:
 271               	.LBE26:
 272 00ac 8823      		tst r24
 273 00ae 01F0      		breq .L29
 240:./lcd.h       ****         lcd_write(c);
 274               		.loc 1 240 0
 275 00b0 0E94 0000 		call lcd_write
 276               	.LVL17:
 277 00b4 FE01      		movw r30,r28
 278 00b6 00C0      		rjmp .L27
 279               	.LVL18:
 280               	.L29:
 281               	/* epilogue start */
 241:./lcd.h       **** }
 282               		.loc 1 241 0
 283 00b8 DF91      		pop r29
 284 00ba CF91      		pop r28
 285               	.LVL19:
 286 00bc 0895      		ret
 287               		.cfi_endproc
 288               	.LFE16:
 290               	.global	lcd_putch
 292               	lcd_putch:
 293               	.LFB17:
 242:./lcd.h       **** /* write one character to the LCD */
 243:./lcd.h       **** 
 244:./lcd.h       **** void lcd_putch(char c)
 245:./lcd.h       **** {
 294               		.loc 1 245 0
 295               		.cfi_startproc
 296               	.LVL20:
 297               	/* prologue: function */
 298               	/* frame size = 0 */
 299               	/* stack size = 0 */
 300               	.L__stack_usage = 0
 246:./lcd.h       **** 	LCD_RS_PORT |= (1 << LCD_RS_PIN);	// write characters
 301               		.loc 1 246 0
 302 00be D89A      		sbi 0x1b,0
 247:./lcd.h       **** 	lcd_write( c );
 303               		.loc 1 247 0
 304 00c0 0C94 0000 		jmp lcd_write
 305               	.LVL21:
 306               		.cfi_endproc
 307               	.LFE17:
 309               	.global	lcd_goto
 311               	lcd_goto:
 312               	.LFB18:
 248:./lcd.h       **** }
 249:./lcd.h       **** 
 250:./lcd.h       **** /*
 251:./lcd.h       ****  * Go to the specified position
 252:./lcd.h       ****  */
 253:./lcd.h       **** 
 254:./lcd.h       **** void lcd_goto(unsigned char pos)
 255:./lcd.h       **** {
 313               		.loc 1 255 0
 314               		.cfi_startproc
 315               	.LVL22:
 316               	/* prologue: function */
 317               	/* frame size = 0 */
 318               	/* stack size = 0 */
 319               	.L__stack_usage = 0
 256:./lcd.h       **** 	LCD_RS_PORT &= ~(1 << LCD_RS_PIN);
 320               		.loc 1 256 0
 321 00c4 D898      		cbi 0x1b,0
 257:./lcd.h       **** 	lcd_write(0x80|pos);
 322               		.loc 1 257 0
 323 00c6 8068      		ori r24,lo8(-128)
 324               	.LVL23:
 325 00c8 0C94 0000 		jmp lcd_write
 326               	.LVL24:
 327               		.cfi_endproc
 328               	.LFE18:
 330               	.global	lcd_init
 332               	lcd_init:
 333               	.LFB19:
 258:./lcd.h       **** }
 259:./lcd.h       **** 
 260:./lcd.h       **** 
 261:./lcd.h       **** 
 262:./lcd.h       **** void lcd_init()
 263:./lcd.h       **** {
 334               		.loc 1 263 0
 335               		.cfi_startproc
 336               	/* prologue: function */
 337               	/* frame size = 0 */
 338               	/* stack size = 0 */
 339               	.L__stack_usage = 0
 264:./lcd.h       **** 	DDR(LCD_RS_PORT) |= (1 << LCD_RS_PIN);
 340               		.loc 1 264 0
 341 00cc D09A      		sbi 0x1a,0
 265:./lcd.h       **** 	DDR(LCD_EN_PORT) |= (1 << LCD_EN_PIN);
 342               		.loc 1 265 0
 343 00ce D19A      		sbi 0x1a,1
 266:./lcd.h       **** 
 267:./lcd.h       **** 	DDR(LCD_D7_PORT) |= (1 << LCD_D7_PIN);
 344               		.loc 1 267 0
 345 00d0 D59A      		sbi 0x1a,5
 268:./lcd.h       **** 	DDR(LCD_D6_PORT) |= (1 << LCD_D6_PIN);
 346               		.loc 1 268 0
 347 00d2 D49A      		sbi 0x1a,4
 269:./lcd.h       **** 	DDR(LCD_D5_PORT) |= (1 << LCD_D5_PIN);
 348               		.loc 1 269 0
 349 00d4 D39A      		sbi 0x1a,3
 270:./lcd.h       **** 	DDR(LCD_D4_PORT) |= (1 << LCD_D4_PIN);
 350               		.loc 1 270 0
 351 00d6 D29A      		sbi 0x1a,2
 271:./lcd.h       **** 
 272:./lcd.h       **** 	LCD_RS_PORT &= ~(1 << LCD_RS_PIN);
 352               		.loc 1 272 0
 353 00d8 D898      		cbi 0x1b,0
 273:./lcd.h       **** 	LCD_EN_PORT &= ~(1 << LCD_EN_PIN);
 354               		.loc 1 273 0
 355 00da D998      		cbi 0x1b,1
 356               	.LVL25:
 357               	.LBB27:
 358               	.LBB28:
 163:/usr/lib/avr/include/util/delay.h **** 
 359               		.loc 2 163 0
 360 00dc 8FE5      		ldi r24,lo8(-5537)
 361 00de 9AEE      		ldi r25,hi8(-5537)
 362 00e0 0197      	1:	sbiw r24,1
 363 00e2 01F4      		brne 1b
 364 00e4 00C0      		rjmp .
 365 00e6 0000      		nop
 366               	.LBE28:
 367               	.LBE27:
 274:./lcd.h       **** 
 275:./lcd.h       **** 	_delay_ms(15);	// wait 15mSec after power applied,
 276:./lcd.h       **** 
 277:./lcd.h       **** 	LCD_D4_PORT |= (1 << LCD_D4_PIN);//0x3 & 0x01;				//bit0 000X
 368               		.loc 1 277 0
 369 00e8 DA9A      		sbi 0x1b,2
 278:./lcd.h       **** 	LCD_D5_PORT |= (1 << LCD_D5_PIN);//(0x3>>1) & 0x01;		//bit1 00XY -> 000X
 370               		.loc 1 278 0
 371 00ea DB9A      		sbi 0x1b,3
 279:./lcd.h       **** 	LCD_D6_PORT &= ~(1 << LCD_D6_PIN);//(0x3>>2) & 0x01;		//bit2 0XYZ -> 000X
 372               		.loc 1 279 0
 373 00ec DC98      		cbi 0x1b,4
 280:./lcd.h       **** 	LCD_D7_PORT &= ~(1 << LCD_D7_PIN);//(0x3>>3) & 0x01;		//bit3 XYZW -> 000X
 374               		.loc 1 280 0
 375 00ee DD98      		cbi 0x1b,5
 281:./lcd.h       **** 
 282:./lcd.h       **** 	LCD_STROBE();
 376               		.loc 1 282 0
 377 00f0 D99A      		sbi 0x1b,1
 378 00f2 D998      		cbi 0x1b,1
 379               	.LVL26:
 380               	.LBB29:
 381               	.LBB30:
 163:/usr/lib/avr/include/util/delay.h **** 
 382               		.loc 2 163 0
 383 00f4 8FE1      		ldi r24,lo8(19999)
 384 00f6 9EE4      		ldi r25,hi8(19999)
 385 00f8 0197      	1:	sbiw r24,1
 386 00fa 01F4      		brne 1b
 387 00fc 00C0      		rjmp .
 388 00fe 0000      		nop
 389               	.LBE30:
 390               	.LBE29:
 283:./lcd.h       **** 	_delay_ms(5);
 284:./lcd.h       **** 	LCD_STROBE();
 391               		.loc 1 284 0
 392 0100 D99A      		sbi 0x1b,1
 393 0102 D998      		cbi 0x1b,1
 394               	.LVL27:
 395               	.LBB31:
 396               	.LBB32:
 397               		.loc 2 245 0
 398 0104 8FE1      		ldi r24,lo8(799)
 399 0106 93E0      		ldi r25,hi8(799)
 400 0108 0197      	1:	sbiw r24,1
 401 010a 01F4      		brne 1b
 402 010c 00C0      		rjmp .
 403 010e 0000      		nop
 404               	.LBE32:
 405               	.LBE31:
 285:./lcd.h       **** 	_delay_us(200);
 286:./lcd.h       **** 	LCD_STROBE();
 406               		.loc 1 286 0
 407 0110 D99A      		sbi 0x1b,1
 408 0112 D998      		cbi 0x1b,1
 409               	.LVL28:
 410               	.LBB33:
 411               	.LBB34:
 412               		.loc 2 245 0
 413 0114 8FE1      		ldi r24,lo8(799)
 414 0116 93E0      		ldi r25,hi8(799)
 415 0118 0197      	1:	sbiw r24,1
 416 011a 01F4      		brne 1b
 417 011c 00C0      		rjmp .
 418 011e 0000      		nop
 419               	.LBE34:
 420               	.LBE33:
 287:./lcd.h       **** 	_delay_us(200);
 288:./lcd.h       **** 
 289:./lcd.h       **** 	// Four bit mode
 290:./lcd.h       **** 	LCD_D4_PORT &= ~(1 << LCD_D4_PIN);	//2 & 0x01
 421               		.loc 1 290 0
 422 0120 DA98      		cbi 0x1b,2
 291:./lcd.h       **** 	LCD_D5_PORT |=  (1 << LCD_D5_PIN);	//(2>>1) & 0x01
 423               		.loc 1 291 0
 424 0122 DB9A      		sbi 0x1b,3
 292:./lcd.h       **** 	LCD_D6_PORT &= ~(1 << LCD_D6_PIN);	//(2>>2) & 0x01
 425               		.loc 1 292 0
 426 0124 DC98      		cbi 0x1b,4
 293:./lcd.h       **** 	LCD_D7_PORT &= ~(1 << LCD_D7_PIN);	//(2>>3) & 0x01
 427               		.loc 1 293 0
 428 0126 DD98      		cbi 0x1b,5
 294:./lcd.h       **** 
 295:./lcd.h       **** 	LCD_STROBE();
 429               		.loc 1 295 0
 430 0128 D99A      		sbi 0x1b,1
 431 012a D998      		cbi 0x1b,1
 296:./lcd.h       **** 
 297:./lcd.h       **** 	lcd_write(0x28);		// Set interface length: nibblemode, 2line, 5x7dot
 432               		.loc 1 297 0
 433 012c 88E2      		ldi r24,lo8(40)
 434 012e 0E94 0000 		call lcd_write
 435               	.LVL29:
 298:./lcd.h       **** 	lcd_write(0b00001100);	// Display On, Cursor Off, Cursor Blink off
 436               		.loc 1 298 0
 437 0132 8CE0      		ldi r24,lo8(12)
 438 0134 0E94 0000 		call lcd_write
 439               	.LVL30:
 299:./lcd.h       **** 	lcd_clear();			// Clear screen
 440               		.loc 1 299 0
 441 0138 0E94 0000 		call lcd_clear
 442               	.LVL31:
 300:./lcd.h       **** 	lcd_write(0x6);			// Set entry Mode : increment, displayShiftOff
 443               		.loc 1 300 0
 444 013c 86E0      		ldi r24,lo8(6)
 445 013e 0C94 0000 		jmp lcd_write
 446               	.LVL32:
 447               		.cfi_endproc
 448               	.LFE19:
 450               	.global	lcd_unum_hex
 452               	lcd_unum_hex:
 453               	.LFB20:
 301:./lcd.h       **** }
 302:./lcd.h       **** 
 303:./lcd.h       **** 
 304:./lcd.h       **** 
 305:./lcd.h       **** 
 306:./lcd.h       **** const char PROGMEM chex[] =			{	'0', '1', '2', '3', '4', '5', '6', '7',
 307:./lcd.h       **** 									'8', '9', 'A', 'B', 'C', 'D', 'E', 'F'  };
 308:./lcd.h       **** const char PROGMEM chex_wBlanking[] = {	' ', '1', '2', '3', '4', '5', '6', '7',
 309:./lcd.h       **** 									'8', '9', 'A', 'B', 'C', 'D', 'E', 'F'  };
 310:./lcd.h       **** 
 311:./lcd.h       **** //without blanking of leading zeros
 312:./lcd.h       **** void lcd_unum_hex(uint16_t num)
 313:./lcd.h       **** {
 454               		.loc 1 313 0
 455               		.cfi_startproc
 456               	.LVL33:
 457 0142 CF93      		push r28
 458               	.LCFI4:
 459               		.cfi_def_cfa_offset 3
 460               		.cfi_offset 28, -2
 461 0144 DF93      		push r29
 462               	.LCFI5:
 463               		.cfi_def_cfa_offset 4
 464               		.cfi_offset 29, -3
 465               	/* prologue: function */
 466               	/* frame size = 0 */
 467               	/* stack size = 2 */
 468               	.L__stack_usage = 2
 469 0146 EC01      		movw r28,r24
 470               	.LVL34:
 471               	.LBB35:
 314:./lcd.h       **** 	lcd_putch(pgm_read_byte(&chex[(num>>12)&0x0F]));
 472               		.loc 1 314 0
 473 0148 FC01      		movw r30,r24
 474 014a EF2F      		mov r30,r31
 475 014c FF27      		clr r31
 476 014e E295      		swap r30
 477 0150 EF70      		andi r30,0x0f
 478               	.LVL35:
 479 0152 E050      		subi r30,lo8(-(chex))
 480 0154 F040      		sbci r31,hi8(-(chex))
 481               	.LVL36:
 482               	/* #APP */
 483               	 ;  314 "./lcd.h" 1
 484 0156 8491      		lpm r24, Z
 485               		
 486               	 ;  0 "" 2
 487               	.LVL37:
 488               	/* #NOAPP */
 489               	.LBE35:
 490 0158 0E94 0000 		call lcd_putch
 491               	.LVL38:
 492               	.LBB36:
 315:./lcd.h       **** 	lcd_putch(pgm_read_byte(&chex[(num>>8)&0x0F]));
 493               		.loc 1 315 0
 494 015c ED2F      		mov r30,r29
 495 015e FF27      		clr r31
 496 0160 EF70      		andi r30,15
 497 0162 FF27      		clr r31
 498 0164 E050      		subi r30,lo8(-(chex))
 499 0166 F040      		sbci r31,hi8(-(chex))
 500               	.LVL39:
 501               	/* #APP */
 502               	 ;  315 "./lcd.h" 1
 503 0168 8491      		lpm r24, Z
 504               		
 505               	 ;  0 "" 2
 506               	.LVL40:
 507               	/* #NOAPP */
 508               	.LBE36:
 509 016a 0E94 0000 		call lcd_putch
 510               	.LVL41:
 511               	.LBB37:
 316:./lcd.h       **** 	lcd_putch(pgm_read_byte(&chex[(num>>4)&0x0F]));
 512               		.loc 1 316 0
 513 016e FE01      		movw r30,r28
 514 0170 24E0      		ldi r18,4
 515               		1:
 516 0172 F695      		lsr r31
 517 0174 E795      		ror r30
 518 0176 2A95      		dec r18
 519 0178 01F4      		brne 1b
 520 017a EF70      		andi r30,15
 521 017c FF27      		clr r31
 522 017e E050      		subi r30,lo8(-(chex))
 523 0180 F040      		sbci r31,hi8(-(chex))
 524               	.LVL42:
 525               	/* #APP */
 526               	 ;  316 "./lcd.h" 1
 527 0182 8491      		lpm r24, Z
 528               		
 529               	 ;  0 "" 2
 530               	.LVL43:
 531               	/* #NOAPP */
 532               	.LBE37:
 533 0184 0E94 0000 		call lcd_putch
 534               	.LVL44:
 535               	.LBB38:
 317:./lcd.h       **** 	lcd_putch(pgm_read_byte(&chex[num&0x0F]));
 536               		.loc 1 317 0
 537 0188 FE01      		movw r30,r28
 538 018a EF70      		andi r30,15
 539 018c FF27      		clr r31
 540 018e E050      		subi r30,lo8(-(chex))
 541 0190 F040      		sbci r31,hi8(-(chex))
 542               	.LVL45:
 543               	/* #APP */
 544               	 ;  317 "./lcd.h" 1
 545 0192 8491      		lpm r24, Z
 546               		
 547               	 ;  0 "" 2
 548               	.LVL46:
 549               	/* epilogue start */
 550               	/* #NOAPP */
 551               	.LBE38:
 318:./lcd.h       **** }
 552               		.loc 1 318 0
 553 0194 DF91      		pop r29
 554 0196 CF91      		pop r28
 555               	.LVL47:
 317:./lcd.h       **** 	lcd_putch(pgm_read_byte(&chex[num&0x0F]));
 556               		.loc 1 317 0
 557 0198 0C94 0000 		jmp lcd_putch
 558               	.LVL48:
 559               		.cfi_endproc
 560               	.LFE20:
 562               	.global	lcd_unum_hex_wBlanking
 564               	lcd_unum_hex_wBlanking:
 565               	.LFB21:
 319:./lcd.h       **** 
 320:./lcd.h       **** void lcd_unum_hex_wBlanking(uint16_t num)
 321:./lcd.h       **** {
 566               		.loc 1 321 0
 567               		.cfi_startproc
 568               	.LVL49:
 569 019c CF93      		push r28
 570               	.LCFI6:
 571               		.cfi_def_cfa_offset 3
 572               		.cfi_offset 28, -2
 573 019e DF93      		push r29
 574               	.LCFI7:
 575               		.cfi_def_cfa_offset 4
 576               		.cfi_offset 29, -3
 577               	/* prologue: function */
 578               	/* frame size = 0 */
 579               	/* stack size = 2 */
 580               	.L__stack_usage = 2
 581 01a0 EC01      		movw r28,r24
 582               	.LVL50:
 583               	.LBB39:
 322:./lcd.h       **** 	lcd_putch(pgm_read_byte(&chex_wBlanking[(num>>12)&0x0F]));
 584               		.loc 1 322 0
 585 01a2 FC01      		movw r30,r24
 586 01a4 EF2F      		mov r30,r31
 587 01a6 FF27      		clr r31
 588 01a8 E295      		swap r30
 589 01aa EF70      		andi r30,0x0f
 590               	.LVL51:
 591 01ac E050      		subi r30,lo8(-(chex_wBlanking))
 592 01ae F040      		sbci r31,hi8(-(chex_wBlanking))
 593               	.LVL52:
 594               	/* #APP */
 595               	 ;  322 "./lcd.h" 1
 596 01b0 8491      		lpm r24, Z
 597               		
 598               	 ;  0 "" 2
 599               	.LVL53:
 600               	/* #NOAPP */
 601               	.LBE39:
 602 01b2 0E94 0000 		call lcd_putch
 603               	.LVL54:
 604               	.LBB40:
 323:./lcd.h       **** 	lcd_putch(pgm_read_byte(&chex_wBlanking[(num>>8)&0x0F]));
 605               		.loc 1 323 0
 606 01b6 ED2F      		mov r30,r29
 607 01b8 FF27      		clr r31
 608 01ba EF70      		andi r30,15
 609 01bc FF27      		clr r31
 610 01be E050      		subi r30,lo8(-(chex_wBlanking))
 611 01c0 F040      		sbci r31,hi8(-(chex_wBlanking))
 612               	.LVL55:
 613               	/* #APP */
 614               	 ;  323 "./lcd.h" 1
 615 01c2 8491      		lpm r24, Z
 616               		
 617               	 ;  0 "" 2
 618               	.LVL56:
 619               	/* #NOAPP */
 620               	.LBE40:
 621 01c4 0E94 0000 		call lcd_putch
 622               	.LVL57:
 623               	.LBB41:
 324:./lcd.h       **** 	lcd_putch(pgm_read_byte(&chex_wBlanking[(num>>4)&0x0F]));
 624               		.loc 1 324 0
 625 01c8 FE01      		movw r30,r28
 626 01ca 24E0      		ldi r18,4
 627               		1:
 628 01cc F695      		lsr r31
 629 01ce E795      		ror r30
 630 01d0 2A95      		dec r18
 631 01d2 01F4      		brne 1b
 632 01d4 EF70      		andi r30,15
 633 01d6 FF27      		clr r31
 634 01d8 E050      		subi r30,lo8(-(chex_wBlanking))
 635 01da F040      		sbci r31,hi8(-(chex_wBlanking))
 636               	.LVL58:
 637               	/* #APP */
 638               	 ;  324 "./lcd.h" 1
 639 01dc 8491      		lpm r24, Z
 640               		
 641               	 ;  0 "" 2
 642               	.LVL59:
 643               	/* #NOAPP */
 644               	.LBE41:
 645 01de 0E94 0000 		call lcd_putch
 646               	.LVL60:
 647               	.LBB42:
 325:./lcd.h       **** 	lcd_putch(pgm_read_byte(&chex[num&0x0F]));
 648               		.loc 1 325 0
 649 01e2 FE01      		movw r30,r28
 650 01e4 EF70      		andi r30,15
 651 01e6 FF27      		clr r31
 652 01e8 E050      		subi r30,lo8(-(chex))
 653 01ea F040      		sbci r31,hi8(-(chex))
 654               	.LVL61:
 655               	/* #APP */
 656               	 ;  325 "./lcd.h" 1
 657 01ec 8491      		lpm r24, Z
 658               		
 659               	 ;  0 "" 2
 660               	.LVL62:
 661               	/* epilogue start */
 662               	/* #NOAPP */
 663               	.LBE42:
 326:./lcd.h       **** }
 664               		.loc 1 326 0
 665 01ee DF91      		pop r29
 666 01f0 CF91      		pop r28
 667               	.LVL63:
 325:./lcd.h       **** 	lcd_putch(pgm_read_byte(&chex[num&0x0F]));
 668               		.loc 1 325 0
 669 01f2 0C94 0000 		jmp lcd_putch
 670               	.LVL64:
 671               		.cfi_endproc
 672               	.LFE21:
 674               	.global	lcd_unum3
 676               	lcd_unum3:
 677               	.LFB22:
 327:./lcd.h       **** 
 328:./lcd.h       **** void lcd_unum3(uint8_t num)
 329:./lcd.h       **** {
 678               		.loc 1 329 0
 679               		.cfi_startproc
 680               	.LVL65:
 681 01f6 0F93      		push r16
 682               	.LCFI8:
 683               		.cfi_def_cfa_offset 3
 684               		.cfi_offset 16, -2
 685 01f8 1F93      		push r17
 686               	.LCFI9:
 687               		.cfi_def_cfa_offset 4
 688               		.cfi_offset 17, -3
 689 01fa CF93      		push r28
 690               	.LCFI10:
 691               		.cfi_def_cfa_offset 5
 692               		.cfi_offset 28, -4
 693 01fc DF93      		push r29
 694               	.LCFI11:
 695               		.cfi_def_cfa_offset 6
 696               		.cfi_offset 29, -5
 697 01fe 1F92      		push __zero_reg__
 698               	.LCFI12:
 699               		.cfi_def_cfa_offset 7
 700 0200 CDB7      		in r28,__SP_L__
 701 0202 DEB7      		in r29,__SP_H__
 702               	.LCFI13:
 703               		.cfi_def_cfa_register 28
 704               	/* prologue: function */
 705               	/* frame size = 1 */
 706               	/* stack size = 5 */
 707               	.L__stack_usage = 5
 708 0204 182F      		mov r17,r24
 330:./lcd.h       **** 	lcd_putch(num/100 + '0');
 709               		.loc 1 330 0
 710 0206 64E6      		ldi r22,lo8(100)
 711 0208 0E94 0000 		call __udivmodqi4
 712               	.LVL66:
 713 020c 805D      		subi r24,lo8(-(48))
 714 020e 9983      		std Y+1,r25
 715 0210 0E94 0000 		call lcd_putch
 716               	.LVL67:
 331:./lcd.h       **** 	lcd_putch((num%100)/10 + '0');
 717               		.loc 1 331 0
 718 0214 0AE0      		ldi r16,lo8(10)
 719 0216 9981      		ldd r25,Y+1
 720 0218 892F      		mov r24,r25
 721 021a 602F      		mov r22,r16
 722 021c 0E94 0000 		call __udivmodqi4
 723 0220 805D      		subi r24,lo8(-(48))
 724 0222 0E94 0000 		call lcd_putch
 725               	.LVL68:
 332:./lcd.h       **** 	lcd_putch(num%10 + '0');
 726               		.loc 1 332 0
 727 0226 812F      		mov r24,r17
 728 0228 602F      		mov r22,r16
 729 022a 0E94 0000 		call __udivmodqi4
 730 022e 80E3      		ldi r24,lo8(48)
 731 0230 890F      		add r24,r25
 732               	/* epilogue start */
 333:./lcd.h       **** }
 733               		.loc 1 333 0
 734 0232 0F90      		pop __tmp_reg__
 735 0234 DF91      		pop r29
 736 0236 CF91      		pop r28
 737 0238 1F91      		pop r17
 738               	.LVL69:
 739 023a 0F91      		pop r16
 332:./lcd.h       **** 	lcd_putch(num%10 + '0');
 740               		.loc 1 332 0
 741 023c 0C94 0000 		jmp lcd_putch
 742               	.LVL70:
 743               		.cfi_endproc
 744               	.LFE22:
 746               	.global	lcd_unum
 748               	lcd_unum:
 749               	.LFB23:
 334:./lcd.h       **** 
 335:./lcd.h       **** void lcd_unum(uint16_t num)
 336:./lcd.h       **** {
 750               		.loc 1 336 0
 751               		.cfi_startproc
 752               	.LVL71:
 753 0240 1F93      		push r17
 754               	.LCFI14:
 755               		.cfi_def_cfa_offset 3
 756               		.cfi_offset 17, -2
 757 0242 CF93      		push r28
 758               	.LCFI15:
 759               		.cfi_def_cfa_offset 4
 760               		.cfi_offset 28, -3
 761 0244 DF93      		push r29
 762               	.LCFI16:
 763               		.cfi_def_cfa_offset 5
 764               		.cfi_offset 29, -4
 765               	/* prologue: function */
 766               	/* frame size = 0 */
 767               	/* stack size = 3 */
 768               	.L__stack_usage = 3
 769               	.LVL72:
 770               		.loc 1 336 0
 771 0246 2FE0      		ldi r18,lo8(15)
 772 0248 30E0      		ldi r19,0
 337:./lcd.h       ****     uint16_t bcd = 0;
 338:./lcd.h       ****     uint8_t bcd4 = 0;
 773               		.loc 1 338 0
 774 024a 10E0      		ldi r17,0
 337:./lcd.h       ****     uint16_t bcd = 0;
 775               		.loc 1 337 0
 776 024c C0E0      		ldi r28,0
 777 024e D0E0      		ldi r29,0
 778               	.LBB43:
 339:./lcd.h       ****     for(uint8_t i=16; i!=0; --i)
 340:./lcd.h       ****     {
 341:./lcd.h       **** 	    if((bcd&0x000F) >= 0x5)
 342:./lcd.h       ****             bcd+=0x3;
 343:./lcd.h       ****         if((bcd&0x00F0) >= 0x50)
 344:./lcd.h       ****             bcd+=0x30;
 345:./lcd.h       ****         if((bcd&0x0F00) >= 0x500)
 346:./lcd.h       ****             bcd+=0x300;
 347:./lcd.h       ****         if((bcd&0xF000) >= 0x5000)
 348:./lcd.h       ****             bcd+=0x3000;
 349:./lcd.h       **** 
 350:./lcd.h       ****         bcd4 <<= 1;
 351:./lcd.h       ****         bcd4 += ((bcd&0x8000)?1:0);
 352:./lcd.h       ****         bcd <<= 1;
 353:./lcd.h       ****         bcd += ((num&(1<<(i-1)))?1:0);
 779               		.loc 1 353 0
 780 0250 E1E0      		ldi r30,lo8(1)
 781 0252 F0E0      		ldi r31,0
 782               	.LVL73:
 783               	.L42:
 341:./lcd.h       ****             bcd+=0x3;
 784               		.loc 1 341 0
 785 0254 AE01      		movw r20,r28
 786 0256 4F70      		andi r20,15
 787 0258 5527      		clr r21
 788 025a 4530      		cpi r20,5
 789 025c 5105      		cpc r21,__zero_reg__
 790 025e 00F0      		brlo .L37
 342:./lcd.h       ****         if((bcd&0x00F0) >= 0x50)
 791               		.loc 1 342 0
 792 0260 2396      		adiw r28,3
 793               	.LVL74:
 794               	.L37:
 343:./lcd.h       ****             bcd+=0x30;
 795               		.loc 1 343 0
 796 0262 AE01      		movw r20,r28
 797 0264 407F      		andi r20,240
 798 0266 5527      		clr r21
 799 0268 4035      		cpi r20,80
 800 026a 5105      		cpc r21,__zero_reg__
 801 026c 00F0      		brlo .L38
 344:./lcd.h       ****         if((bcd&0x0F00) >= 0x500)
 802               		.loc 1 344 0
 803 026e E096      		adiw r28,48
 804               	.LVL75:
 805               	.L38:
 345:./lcd.h       ****             bcd+=0x300;
 806               		.loc 1 345 0
 807 0270 AE01      		movw r20,r28
 808 0272 4427      		clr r20
 809 0274 5F70      		andi r21,15
 810 0276 4115      		cp r20,__zero_reg__
 811 0278 5540      		sbci r21,5
 812 027a 00F0      		brlo .L39
 346:./lcd.h       ****         if((bcd&0xF000) >= 0x5000)
 813               		.loc 1 346 0
 814 027c DD5F      		subi r29,-3
 815               	.LVL76:
 816               	.L39:
 347:./lcd.h       ****             bcd+=0x3000;
 817               		.loc 1 347 0
 818 027e AE01      		movw r20,r28
 819 0280 4427      		clr r20
 820 0282 507F      		andi r21,240
 821 0284 4115      		cp r20,__zero_reg__
 822 0286 5045      		sbci r21,80
 823 0288 00F0      		brlo .L40
 348:./lcd.h       **** 
 824               		.loc 1 348 0
 825 028a D05D      		subi r29,-48
 826               	.LVL77:
 827               	.L40:
 350:./lcd.h       ****         bcd4 += ((bcd&0x8000)?1:0);
 828               		.loc 1 350 0
 829 028c 110F      		lsl r17
 830               	.LVL78:
 351:./lcd.h       ****         bcd <<= 1;
 831               		.loc 1 351 0
 832 028e 4D2F      		mov r20,r29
 833 0290 441F      		rol r20
 834 0292 4427      		clr r20
 835 0294 441F      		rol r20
 836 0296 140F      		add r17,r20
 837               	.LVL79:
 352:./lcd.h       ****         bcd += ((num&(1<<(i-1)))?1:0);
 838               		.loc 1 352 0
 839 0298 CC0F      		lsl r28
 840 029a DD1F      		rol r29
 841               	.LVL80:
 842               		.loc 1 353 0
 843 029c AF01      		movw r20,r30
 844 029e 022E      		mov r0,r18
 845 02a0 00C0      		rjmp 2f
 846               		1:
 847 02a2 440F      		lsl r20
 848 02a4 551F      		rol r21
 849               		2:
 850 02a6 0A94      		dec r0
 851 02a8 02F4      		brpl 1b
 852 02aa 4823      		and r20,r24
 853 02ac 5923      		and r21,r25
 854 02ae 61E0      		ldi r22,lo8(1)
 855 02b0 70E0      		ldi r23,0
 856 02b2 452B      		or r20,r21
 857 02b4 01F4      		brne .L41
 858 02b6 60E0      		ldi r22,0
 859 02b8 70E0      		ldi r23,0
 860               	.L41:
 861 02ba C60F      		add r28,r22
 862 02bc D71F      		adc r29,r23
 863               	.LVL81:
 864               	.LVL82:
 865 02be 2150      		subi r18,1
 866 02c0 3109      		sbc r19,__zero_reg__
 867 02c2 00F4      		brcc .L42
 868               	.LBE43:
 354:./lcd.h       ****     }
 355:./lcd.h       **** 
 356:./lcd.h       ****     lcd_putch((bcd4)?(chex[bcd4]):' ');
 869               		.loc 1 356 0
 870 02c4 1123      		tst r17
 871 02c6 01F0      		breq .L50
 872               		.loc 1 356 0 is_stmt 0 discriminator 1
 873 02c8 E12F      		mov r30,r17
 874 02ca F0E0      		ldi r31,0
 875 02cc E050      		subi r30,lo8(-(chex))
 876 02ce F040      		sbci r31,hi8(-(chex))
 877 02d0 8081      		ld r24,Z
 878               	.LVL83:
 879 02d2 00C0      		rjmp .L43
 880               	.LVL84:
 881               	.L50:
 882               		.loc 1 356 0
 883 02d4 80E2      		ldi r24,lo8(32)
 884               	.LVL85:
 885               	.L43:
 886               		.loc 1 356 0 discriminator 4
 887 02d6 0E94 0000 		call lcd_putch
 888               	.LVL86:
 357:./lcd.h       ****     lcd_putch((!bcd4 && bcd<0x1000)	?' ':(pgm_read_byte(&chex[bcd>>12])));
 889               		.loc 1 357 0 is_stmt 1 discriminator 4
 890 02da 1111      		cpse r17,__zero_reg__
 891 02dc 00C0      		rjmp .L44
 892               		.loc 1 357 0 is_stmt 0 discriminator 2
 893 02de C115      		cp r28,__zero_reg__
 894 02e0 60E1      		ldi r22,16
 895 02e2 D607      		cpc r29,r22
 896 02e4 00F0      		brlo .L51
 897               	.L44:
 898               	.LVL87:
 899               	.LBB44:
 900               		.loc 1 357 0 discriminator 3
 901 02e6 FE01      		movw r30,r28
 902 02e8 EF2F      		mov r30,r31
 903 02ea FF27      		clr r31
 904 02ec E295      		swap r30
 905 02ee EF70      		andi r30,0x0f
 906 02f0 E050      		subi r30,lo8(-(chex))
 907 02f2 F040      		sbci r31,hi8(-(chex))
 908               	.LVL88:
 909               	/* #APP */
 910               	 ;  357 "./lcd.h" 1
 911 02f4 8491      		lpm r24, Z
 912               		
 913               	 ;  0 "" 2
 914               	.LVL89:
 915               	/* #NOAPP */
 916               	.LBE44:
 917 02f6 00C0      		rjmp .L45
 918               	.LVL90:
 919               	.L51:
 920               		.loc 1 357 0
 921 02f8 80E2      		ldi r24,lo8(32)
 922               	.L45:
 923               		.loc 1 357 0 discriminator 6
 924 02fa 0E94 0000 		call lcd_putch
 925               	.LVL91:
 358:./lcd.h       ****     lcd_putch((!bcd4 && bcd<0x100)	?' ':(pgm_read_byte(&chex[(bcd>>8)&0x000F])));
 926               		.loc 1 358 0 is_stmt 1 discriminator 6
 927 02fe 1111      		cpse r17,__zero_reg__
 928 0300 00C0      		rjmp .L46
 929               		.loc 1 358 0 is_stmt 0 discriminator 2
 930 0302 CF3F      		cpi r28,-1
 931 0304 D105      		cpc r29,__zero_reg__
 932 0306 01F0      		breq .L52
 933 0308 00F0      		brlo .L52
 934               	.L46:
 935               	.LVL92:
 936               	.LBB45:
 937               		.loc 1 358 0 discriminator 3
 938 030a ED2F      		mov r30,r29
 939 030c FF27      		clr r31
 940 030e EF70      		andi r30,15
 941 0310 FF27      		clr r31
 942 0312 E050      		subi r30,lo8(-(chex))
 943 0314 F040      		sbci r31,hi8(-(chex))
 944               	.LVL93:
 945               	/* #APP */
 946               	 ;  358 "./lcd.h" 1
 947 0316 8491      		lpm r24, Z
 948               		
 949               	 ;  0 "" 2
 950               	.LVL94:
 951               	/* #NOAPP */
 952               	.LBE45:
 953 0318 00C0      		rjmp .L47
 954               	.LVL95:
 955               	.L52:
 956               		.loc 1 358 0
 957 031a 80E2      		ldi r24,lo8(32)
 958               	.L47:
 959               		.loc 1 358 0 discriminator 6
 960 031c 0E94 0000 		call lcd_putch
 961               	.LVL96:
 359:./lcd.h       ****     lcd_putch((!bcd4 && bcd<0x10)	?' ':(pgm_read_byte(&chex[(bcd>>4)&0x000F])));
 962               		.loc 1 359 0 is_stmt 1 discriminator 6
 963 0320 1111      		cpse r17,__zero_reg__
 964 0322 00C0      		rjmp .L48
 965               		.loc 1 359 0 is_stmt 0 discriminator 2
 966 0324 C031      		cpi r28,16
 967 0326 D105      		cpc r29,__zero_reg__
 968 0328 00F0      		brlo .L53
 969               	.L48:
 970               	.LVL97:
 971               	.LBB46:
 972               		.loc 1 359 0 discriminator 3
 973 032a FE01      		movw r30,r28
 974 032c 84E0      		ldi r24,4
 975               		1:
 976 032e F695      		lsr r31
 977 0330 E795      		ror r30
 978 0332 8A95      		dec r24
 979 0334 01F4      		brne 1b
 980 0336 EF70      		andi r30,15
 981 0338 FF27      		clr r31
 982 033a E050      		subi r30,lo8(-(chex))
 983 033c F040      		sbci r31,hi8(-(chex))
 984               	.LVL98:
 985               	/* #APP */
 986               	 ;  359 "./lcd.h" 1
 987 033e 8491      		lpm r24, Z
 988               		
 989               	 ;  0 "" 2
 990               	.LVL99:
 991               	/* #NOAPP */
 992               	.LBE46:
 993 0340 00C0      		rjmp .L49
 994               	.LVL100:
 995               	.L53:
 996               		.loc 1 359 0
 997 0342 80E2      		ldi r24,lo8(32)
 998               	.L49:
 999               		.loc 1 359 0 discriminator 6
 1000 0344 0E94 0000 		call lcd_putch
 1001               	.LVL101:
 1002               	.LBB47:
 360:./lcd.h       ****     lcd_putch(pgm_read_byte(&chex[bcd&0x000F]));
 1003               		.loc 1 360 0 is_stmt 1 discriminator 6
 1004 0348 FE01      		movw r30,r28
 1005 034a EF70      		andi r30,15
 1006 034c FF27      		clr r31
 1007 034e E050      		subi r30,lo8(-(chex))
 1008 0350 F040      		sbci r31,hi8(-(chex))
 1009               	.LVL102:
 1010               	/* #APP */
 1011               	 ;  360 "./lcd.h" 1
 1012 0352 8491      		lpm r24, Z
 1013               		
 1014               	 ;  0 "" 2
 1015               	.LVL103:
 1016               	/* epilogue start */
 1017               	/* #NOAPP */
 1018               	.LBE47:
 361:./lcd.h       **** }
 1019               		.loc 1 361 0 discriminator 6
 1020 0354 DF91      		pop r29
 1021 0356 CF91      		pop r28
 1022               	.LVL104:
 1023 0358 1F91      		pop r17
 1024               	.LVL105:
 360:./lcd.h       ****     lcd_putch(pgm_read_byte(&chex[bcd&0x000F]));
 1025               		.loc 1 360 0 discriminator 6
 1026 035a 0C94 0000 		jmp lcd_putch
 1027               	.LVL106:
 1028               		.cfi_endproc
 1029               	.LFE23:
 1031               	.global	lcd_num
 1033               	lcd_num:
 1034               	.LFB24:
 362:./lcd.h       **** 
 363:./lcd.h       **** void lcd_num( int num )
 364:./lcd.h       **** {
 1035               		.loc 1 364 0
 1036               		.cfi_startproc
 1037               	.LVL107:
 1038 035e CF93      		push r28
 1039               	.LCFI17:
 1040               		.cfi_def_cfa_offset 3
 1041               		.cfi_offset 28, -2
 1042 0360 DF93      		push r29
 1043               	.LCFI18:
 1044               		.cfi_def_cfa_offset 4
 1045               		.cfi_offset 29, -3
 1046 0362 00D0      		rcall .
 1047 0364 00D0      		rcall .
 1048 0366 00D0      		rcall .
 1049               	.LCFI19:
 1050               		.cfi_def_cfa_offset 10
 1051 0368 CDB7      		in r28,__SP_L__
 1052 036a DEB7      		in r29,__SP_H__
 1053               	.LCFI20:
 1054               		.cfi_def_cfa_register 28
 1055               	/* prologue: function */
 1056               	/* frame size = 6 */
 1057               	/* stack size = 8 */
 1058               	.L__stack_usage = 8
 1059               	.LVL108:
 1060               	.LBB48:
 1061               	.LBB49:
 1062               		.file 3 "/usr/lib/avr/include/stdlib.h"
   1:/usr/lib/avr/include/stdlib.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/stdlib.h ****    Copyright (c) 2004,2007 Joerg Wunsch
   3:/usr/lib/avr/include/stdlib.h **** 
   4:/usr/lib/avr/include/stdlib.h ****    Portions of documentation Copyright (c) 1990, 1991, 1993, 1994
   5:/usr/lib/avr/include/stdlib.h ****    The Regents of the University of California.
   6:/usr/lib/avr/include/stdlib.h **** 
   7:/usr/lib/avr/include/stdlib.h ****    All rights reserved.
   8:/usr/lib/avr/include/stdlib.h **** 
   9:/usr/lib/avr/include/stdlib.h ****    Redistribution and use in source and binary forms, with or without
  10:/usr/lib/avr/include/stdlib.h ****    modification, are permitted provided that the following conditions are met:
  11:/usr/lib/avr/include/stdlib.h **** 
  12:/usr/lib/avr/include/stdlib.h ****    * Redistributions of source code must retain the above copyright
  13:/usr/lib/avr/include/stdlib.h ****      notice, this list of conditions and the following disclaimer.
  14:/usr/lib/avr/include/stdlib.h **** 
  15:/usr/lib/avr/include/stdlib.h ****    * Redistributions in binary form must reproduce the above copyright
  16:/usr/lib/avr/include/stdlib.h ****      notice, this list of conditions and the following disclaimer in
  17:/usr/lib/avr/include/stdlib.h ****      the documentation and/or other materials provided with the
  18:/usr/lib/avr/include/stdlib.h ****      distribution.
  19:/usr/lib/avr/include/stdlib.h **** 
  20:/usr/lib/avr/include/stdlib.h ****    * Neither the name of the copyright holders nor the names of
  21:/usr/lib/avr/include/stdlib.h ****      contributors may be used to endorse or promote products derived
  22:/usr/lib/avr/include/stdlib.h ****      from this software without specific prior written permission.
  23:/usr/lib/avr/include/stdlib.h **** 
  24:/usr/lib/avr/include/stdlib.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  25:/usr/lib/avr/include/stdlib.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  26:/usr/lib/avr/include/stdlib.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  27:/usr/lib/avr/include/stdlib.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  28:/usr/lib/avr/include/stdlib.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  29:/usr/lib/avr/include/stdlib.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  30:/usr/lib/avr/include/stdlib.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  31:/usr/lib/avr/include/stdlib.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  32:/usr/lib/avr/include/stdlib.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  33:/usr/lib/avr/include/stdlib.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  34:/usr/lib/avr/include/stdlib.h ****   POSSIBILITY OF SUCH DAMAGE.
  35:/usr/lib/avr/include/stdlib.h **** 
  36:/usr/lib/avr/include/stdlib.h ****   $Id$
  37:/usr/lib/avr/include/stdlib.h **** */
  38:/usr/lib/avr/include/stdlib.h **** 
  39:/usr/lib/avr/include/stdlib.h **** #ifndef _STDLIB_H_
  40:/usr/lib/avr/include/stdlib.h **** #define	_STDLIB_H_ 1
  41:/usr/lib/avr/include/stdlib.h **** 
  42:/usr/lib/avr/include/stdlib.h **** #ifndef __ASSEMBLER__
  43:/usr/lib/avr/include/stdlib.h **** 
  44:/usr/lib/avr/include/stdlib.h **** #define __need_NULL
  45:/usr/lib/avr/include/stdlib.h **** #define __need_size_t
  46:/usr/lib/avr/include/stdlib.h **** #define __need_wchar_t
  47:/usr/lib/avr/include/stdlib.h **** #include <stddef.h>
  48:/usr/lib/avr/include/stdlib.h **** 
  49:/usr/lib/avr/include/stdlib.h **** #ifndef __ptr_t
  50:/usr/lib/avr/include/stdlib.h **** #define __ptr_t void *
  51:/usr/lib/avr/include/stdlib.h **** #endif
  52:/usr/lib/avr/include/stdlib.h **** 
  53:/usr/lib/avr/include/stdlib.h **** #ifdef __cplusplus
  54:/usr/lib/avr/include/stdlib.h **** extern "C" {
  55:/usr/lib/avr/include/stdlib.h **** #endif
  56:/usr/lib/avr/include/stdlib.h **** 
  57:/usr/lib/avr/include/stdlib.h **** /** \file */
  58:/usr/lib/avr/include/stdlib.h **** 
  59:/usr/lib/avr/include/stdlib.h **** /** \defgroup avr_stdlib <stdlib.h>: General utilities
  60:/usr/lib/avr/include/stdlib.h ****     \code #include <stdlib.h> \endcode
  61:/usr/lib/avr/include/stdlib.h **** 
  62:/usr/lib/avr/include/stdlib.h ****     This file declares some basic C macros and functions as
  63:/usr/lib/avr/include/stdlib.h ****     defined by the ISO standard, plus some AVR-specific extensions.
  64:/usr/lib/avr/include/stdlib.h **** */
  65:/usr/lib/avr/include/stdlib.h **** 
  66:/usr/lib/avr/include/stdlib.h **** /*@{*/
  67:/usr/lib/avr/include/stdlib.h **** /** Result type for function div(). */
  68:/usr/lib/avr/include/stdlib.h **** typedef struct {
  69:/usr/lib/avr/include/stdlib.h **** 	int quot;                   /**< The Quotient. */
  70:/usr/lib/avr/include/stdlib.h **** 	int rem;                    /**< The Remainder. */
  71:/usr/lib/avr/include/stdlib.h **** } div_t;
  72:/usr/lib/avr/include/stdlib.h **** 
  73:/usr/lib/avr/include/stdlib.h **** /** Result type for function ldiv(). */
  74:/usr/lib/avr/include/stdlib.h **** typedef struct {
  75:/usr/lib/avr/include/stdlib.h **** 	long quot;                  /**< The Quotient. */
  76:/usr/lib/avr/include/stdlib.h **** 	long rem;                   /**< The Remainder. */
  77:/usr/lib/avr/include/stdlib.h **** } ldiv_t;
  78:/usr/lib/avr/include/stdlib.h **** 
  79:/usr/lib/avr/include/stdlib.h **** /** Comparision function type for qsort(), just for convenience. */
  80:/usr/lib/avr/include/stdlib.h **** typedef int (*__compar_fn_t)(const void *, const void *);
  81:/usr/lib/avr/include/stdlib.h **** 
  82:/usr/lib/avr/include/stdlib.h **** #ifndef __DOXYGEN__
  83:/usr/lib/avr/include/stdlib.h **** 
  84:/usr/lib/avr/include/stdlib.h **** #ifndef __ATTR_CONST__
  85:/usr/lib/avr/include/stdlib.h **** # define __ATTR_CONST__ __attribute__((__const__))
  86:/usr/lib/avr/include/stdlib.h **** #endif
  87:/usr/lib/avr/include/stdlib.h **** 
  88:/usr/lib/avr/include/stdlib.h **** #ifndef __ATTR_MALLOC__
  89:/usr/lib/avr/include/stdlib.h **** # define __ATTR_MALLOC__ __attribute__((__malloc__))
  90:/usr/lib/avr/include/stdlib.h **** #endif
  91:/usr/lib/avr/include/stdlib.h **** 
  92:/usr/lib/avr/include/stdlib.h **** #ifndef __ATTR_NORETURN__
  93:/usr/lib/avr/include/stdlib.h **** # define __ATTR_NORETURN__ __attribute__((__noreturn__))
  94:/usr/lib/avr/include/stdlib.h **** #endif
  95:/usr/lib/avr/include/stdlib.h **** 
  96:/usr/lib/avr/include/stdlib.h **** #ifndef __ATTR_PURE__
  97:/usr/lib/avr/include/stdlib.h **** # define __ATTR_PURE__ __attribute__((__pure__))
  98:/usr/lib/avr/include/stdlib.h **** #endif
  99:/usr/lib/avr/include/stdlib.h **** 
 100:/usr/lib/avr/include/stdlib.h **** #ifndef	__ATTR_GNU_INLINE__
 101:/usr/lib/avr/include/stdlib.h **** # ifdef  __GNUC_STDC_INLINE__
 102:/usr/lib/avr/include/stdlib.h **** #  define __ATTR_GNU_INLINE__   __attribute__((__gnu_inline__))
 103:/usr/lib/avr/include/stdlib.h **** # else
 104:/usr/lib/avr/include/stdlib.h **** #  define __ATTR_GNU_INLINE__
 105:/usr/lib/avr/include/stdlib.h **** # endif
 106:/usr/lib/avr/include/stdlib.h **** #endif
 107:/usr/lib/avr/include/stdlib.h **** 
 108:/usr/lib/avr/include/stdlib.h **** #endif
 109:/usr/lib/avr/include/stdlib.h **** 
 110:/usr/lib/avr/include/stdlib.h **** /** The abort() function causes abnormal program termination to occur.
 111:/usr/lib/avr/include/stdlib.h ****     This realization disables interrupts and jumps to _exit() function
 112:/usr/lib/avr/include/stdlib.h ****     with argument equal to 1. In the limited AVR environment, execution is
 113:/usr/lib/avr/include/stdlib.h ****     effectively halted by entering an infinite loop. */
 114:/usr/lib/avr/include/stdlib.h **** extern void abort(void) __ATTR_NORETURN__;
 115:/usr/lib/avr/include/stdlib.h **** 
 116:/usr/lib/avr/include/stdlib.h **** /** The abs() function computes the absolute value of the integer \c i.
 117:/usr/lib/avr/include/stdlib.h ****    \note The abs() and labs() functions are builtins of gcc.
 118:/usr/lib/avr/include/stdlib.h **** */
 119:/usr/lib/avr/include/stdlib.h **** extern int abs(int __i) __ATTR_CONST__;
 120:/usr/lib/avr/include/stdlib.h **** #ifndef __DOXYGEN__
 121:/usr/lib/avr/include/stdlib.h **** #define	abs(__i) __builtin_abs(__i)
 122:/usr/lib/avr/include/stdlib.h **** #endif
 123:/usr/lib/avr/include/stdlib.h **** 
 124:/usr/lib/avr/include/stdlib.h **** /** The labs() function computes the absolute value of the long integer
 125:/usr/lib/avr/include/stdlib.h ****     \c i.
 126:/usr/lib/avr/include/stdlib.h ****    \note The abs() and labs() functions are builtins of gcc.
 127:/usr/lib/avr/include/stdlib.h **** */
 128:/usr/lib/avr/include/stdlib.h **** extern long labs(long __i) __ATTR_CONST__;
 129:/usr/lib/avr/include/stdlib.h **** #ifndef __DOXYGEN__
 130:/usr/lib/avr/include/stdlib.h **** #define labs(__i) __builtin_labs(__i)
 131:/usr/lib/avr/include/stdlib.h **** #endif
 132:/usr/lib/avr/include/stdlib.h **** 
 133:/usr/lib/avr/include/stdlib.h **** /**
 134:/usr/lib/avr/include/stdlib.h ****      The bsearch() function searches an array of \c nmemb objects, the
 135:/usr/lib/avr/include/stdlib.h ****      initial member of which is pointed to by \c base, for a member
 136:/usr/lib/avr/include/stdlib.h ****      that matches the object pointed to by \c key.  The size of each
 137:/usr/lib/avr/include/stdlib.h ****      member of the array is specified by \c size.
 138:/usr/lib/avr/include/stdlib.h **** 
 139:/usr/lib/avr/include/stdlib.h ****      The contents of the array should be in ascending sorted order
 140:/usr/lib/avr/include/stdlib.h ****      according to the comparison function referenced by \c compar.
 141:/usr/lib/avr/include/stdlib.h ****      The \c compar routine is expected to have two arguments which
 142:/usr/lib/avr/include/stdlib.h ****      point to the key object and to an array member, in that order,
 143:/usr/lib/avr/include/stdlib.h ****      and should return an integer less than, equal to, or greater than
 144:/usr/lib/avr/include/stdlib.h ****      zero if the key object is found, respectively, to be less than,
 145:/usr/lib/avr/include/stdlib.h ****      to match, or be greater than the array member.
 146:/usr/lib/avr/include/stdlib.h **** 
 147:/usr/lib/avr/include/stdlib.h ****      The bsearch() function returns a pointer to a matching member of
 148:/usr/lib/avr/include/stdlib.h ****      the array, or a null pointer if no match is found.  If two
 149:/usr/lib/avr/include/stdlib.h ****      members compare as equal, which member is matched is unspecified.
 150:/usr/lib/avr/include/stdlib.h **** */
 151:/usr/lib/avr/include/stdlib.h **** extern void *bsearch(const void *__key, const void *__base, size_t __nmemb,
 152:/usr/lib/avr/include/stdlib.h **** 		     size_t __size, int (*__compar)(const void *, const void *));
 153:/usr/lib/avr/include/stdlib.h **** 
 154:/usr/lib/avr/include/stdlib.h **** /* __divmodhi4 and __divmodsi4 from libgcc.a */
 155:/usr/lib/avr/include/stdlib.h **** /**
 156:/usr/lib/avr/include/stdlib.h ****      The div() function computes the value \c num/denom and returns
 157:/usr/lib/avr/include/stdlib.h ****      the quotient and remainder in a structure named \c div_t that
 158:/usr/lib/avr/include/stdlib.h ****      contains two int members named \c quot and \c rem.
 159:/usr/lib/avr/include/stdlib.h **** */
 160:/usr/lib/avr/include/stdlib.h **** extern div_t div(int __num, int __denom) __asm__("__divmodhi4") __ATTR_CONST__;
 161:/usr/lib/avr/include/stdlib.h **** /**
 162:/usr/lib/avr/include/stdlib.h ****      The ldiv() function computes the value \c num/denom and returns
 163:/usr/lib/avr/include/stdlib.h ****      the quotient and remainder in a structure named \c ldiv_t that
 164:/usr/lib/avr/include/stdlib.h ****      contains two long integer members named \c quot and \c rem.
 165:/usr/lib/avr/include/stdlib.h **** */
 166:/usr/lib/avr/include/stdlib.h **** extern ldiv_t ldiv(long __num, long __denom) __asm__("__divmodsi4") __ATTR_CONST__;
 167:/usr/lib/avr/include/stdlib.h **** 
 168:/usr/lib/avr/include/stdlib.h **** /**
 169:/usr/lib/avr/include/stdlib.h ****      The qsort() function is a modified partition-exchange sort, or
 170:/usr/lib/avr/include/stdlib.h ****      quicksort.
 171:/usr/lib/avr/include/stdlib.h **** 
 172:/usr/lib/avr/include/stdlib.h ****      The qsort() function sorts an array of \c nmemb objects, the
 173:/usr/lib/avr/include/stdlib.h ****      initial member of which is pointed to by \c base.  The size of
 174:/usr/lib/avr/include/stdlib.h ****      each object is specified by \c size.  The contents of the array
 175:/usr/lib/avr/include/stdlib.h ****      base are sorted in ascending order according to a comparison
 176:/usr/lib/avr/include/stdlib.h ****      function pointed to by \c compar, which requires two arguments
 177:/usr/lib/avr/include/stdlib.h ****      pointing to the objects being compared.
 178:/usr/lib/avr/include/stdlib.h **** 
 179:/usr/lib/avr/include/stdlib.h ****      The comparison function must return an integer less than, equal
 180:/usr/lib/avr/include/stdlib.h ****      to, or greater than zero if the first argument is considered to
 181:/usr/lib/avr/include/stdlib.h ****      be respectively less than, equal to, or greater than the second.
 182:/usr/lib/avr/include/stdlib.h **** */
 183:/usr/lib/avr/include/stdlib.h **** extern void qsort(void *__base, size_t __nmemb, size_t __size,
 184:/usr/lib/avr/include/stdlib.h **** 		  __compar_fn_t __compar);
 185:/usr/lib/avr/include/stdlib.h **** 
 186:/usr/lib/avr/include/stdlib.h **** /**
 187:/usr/lib/avr/include/stdlib.h ****     The strtol() function converts the string in \c nptr to a long
 188:/usr/lib/avr/include/stdlib.h ****     value.  The conversion is done according to the given base, which
 189:/usr/lib/avr/include/stdlib.h ****     must be between 2 and 36 inclusive, or be the special value 0.
 190:/usr/lib/avr/include/stdlib.h **** 
 191:/usr/lib/avr/include/stdlib.h ****     The string may begin with an arbitrary amount of white space (as
 192:/usr/lib/avr/include/stdlib.h ****     determined by isspace()) followed by a single optional \c '+' or \c '-'
 193:/usr/lib/avr/include/stdlib.h ****     sign.  If \c base is zero or 16, the string may then include a
 194:/usr/lib/avr/include/stdlib.h ****     \c "0x" prefix, and the number will be read in base 16; otherwise,
 195:/usr/lib/avr/include/stdlib.h ****     a zero base is taken as 10 (decimal) unless the next character is
 196:/usr/lib/avr/include/stdlib.h ****     \c '0', in which case it is taken as 8 (octal).
 197:/usr/lib/avr/include/stdlib.h **** 
 198:/usr/lib/avr/include/stdlib.h ****     The remainder of the string is converted to a long value in the
 199:/usr/lib/avr/include/stdlib.h ****     obvious manner, stopping at the first character which is not a
 200:/usr/lib/avr/include/stdlib.h ****     valid digit in the given base.  (In bases above 10, the letter \c 'A'
 201:/usr/lib/avr/include/stdlib.h ****     in either upper or lower case represents 10, \c 'B' represents 11,
 202:/usr/lib/avr/include/stdlib.h ****     and so forth, with \c 'Z' representing 35.)
 203:/usr/lib/avr/include/stdlib.h **** 
 204:/usr/lib/avr/include/stdlib.h ****     If \c endptr is not NULL, strtol() stores the address of the first
 205:/usr/lib/avr/include/stdlib.h ****     invalid character in \c *endptr.  If there were no digits at all,
 206:/usr/lib/avr/include/stdlib.h ****     however, strtol() stores the original value of \c nptr in \c
 207:/usr/lib/avr/include/stdlib.h ****     *endptr.  (Thus, if \c *nptr is not \c '\\0' but \c **endptr is \c '\\0'
 208:/usr/lib/avr/include/stdlib.h ****     on return, the entire string was valid.)
 209:/usr/lib/avr/include/stdlib.h **** 
 210:/usr/lib/avr/include/stdlib.h ****     The strtol() function returns the result of the conversion, unless
 211:/usr/lib/avr/include/stdlib.h ****     the value would underflow or overflow.  If no conversion could be
 212:/usr/lib/avr/include/stdlib.h ****     performed, 0 is returned.  If an overflow or underflow occurs, \c
 213:/usr/lib/avr/include/stdlib.h ****     errno is set to \ref avr_errno "ERANGE" and the function return value
 214:/usr/lib/avr/include/stdlib.h ****     is clamped to \c LONG_MIN or \c LONG_MAX, respectively.
 215:/usr/lib/avr/include/stdlib.h **** */
 216:/usr/lib/avr/include/stdlib.h **** extern long strtol(const char *__nptr, char **__endptr, int __base);
 217:/usr/lib/avr/include/stdlib.h **** 
 218:/usr/lib/avr/include/stdlib.h **** /**
 219:/usr/lib/avr/include/stdlib.h ****     The strtoul() function converts the string in \c nptr to an
 220:/usr/lib/avr/include/stdlib.h ****     unsigned long value.  The conversion is done according to the
 221:/usr/lib/avr/include/stdlib.h ****     given base, which must be between 2 and 36 inclusive, or be the
 222:/usr/lib/avr/include/stdlib.h ****     special value 0.
 223:/usr/lib/avr/include/stdlib.h **** 
 224:/usr/lib/avr/include/stdlib.h ****     The string may begin with an arbitrary amount of white space (as
 225:/usr/lib/avr/include/stdlib.h ****     determined by isspace()) followed by a single optional \c '+' or \c '-'
 226:/usr/lib/avr/include/stdlib.h ****     sign.  If \c base is zero or 16, the string may then include a
 227:/usr/lib/avr/include/stdlib.h ****     \c "0x" prefix, and the number will be read in base 16; otherwise,
 228:/usr/lib/avr/include/stdlib.h ****     a zero base is taken as 10 (decimal) unless the next character is
 229:/usr/lib/avr/include/stdlib.h ****     \c '0', in which case it is taken as 8 (octal).
 230:/usr/lib/avr/include/stdlib.h **** 
 231:/usr/lib/avr/include/stdlib.h ****     The remainder of the string is converted to an unsigned long value
 232:/usr/lib/avr/include/stdlib.h ****     in the obvious manner, stopping at the first character which is
 233:/usr/lib/avr/include/stdlib.h ****     not a valid digit in the given base.  (In bases above 10, the
 234:/usr/lib/avr/include/stdlib.h ****     letter \c 'A' in either upper or lower case represents 10, \c 'B'
 235:/usr/lib/avr/include/stdlib.h ****     represents 11, and so forth, with \c 'Z' representing 35.)
 236:/usr/lib/avr/include/stdlib.h **** 
 237:/usr/lib/avr/include/stdlib.h ****     If \c endptr is not NULL, strtoul() stores the address of the first
 238:/usr/lib/avr/include/stdlib.h ****     invalid character in \c *endptr.  If there were no digits at all,
 239:/usr/lib/avr/include/stdlib.h ****     however, strtoul() stores the original value of \c nptr in \c
 240:/usr/lib/avr/include/stdlib.h ****     *endptr.  (Thus, if \c *nptr is not \c '\\0' but \c **endptr is \c '\\0'
 241:/usr/lib/avr/include/stdlib.h ****     on return, the entire string was valid.)
 242:/usr/lib/avr/include/stdlib.h **** 
 243:/usr/lib/avr/include/stdlib.h ****     The strtoul() function return either the result of the conversion
 244:/usr/lib/avr/include/stdlib.h ****     or, if there was a leading minus sign, the negation of the result
 245:/usr/lib/avr/include/stdlib.h ****     of the conversion, unless the original (non-negated) value would
 246:/usr/lib/avr/include/stdlib.h ****     overflow; in the latter case, strtoul() returns ULONG_MAX, and \c
 247:/usr/lib/avr/include/stdlib.h ****     errno is set to \ref avr_errno "ERANGE".  If no conversion could 
 248:/usr/lib/avr/include/stdlib.h ****     be performed, 0 is returned.
 249:/usr/lib/avr/include/stdlib.h **** */
 250:/usr/lib/avr/include/stdlib.h **** extern unsigned long strtoul(const char *__nptr, char **__endptr, int __base);
 251:/usr/lib/avr/include/stdlib.h **** 
 252:/usr/lib/avr/include/stdlib.h **** /**
 253:/usr/lib/avr/include/stdlib.h ****     The atol() function converts the initial portion of the string
 254:/usr/lib/avr/include/stdlib.h ****     pointed to by \p s to long integer representation. In contrast to
 255:/usr/lib/avr/include/stdlib.h **** 
 256:/usr/lib/avr/include/stdlib.h ****         \code strtol(s, (char **)NULL, 10); \endcode
 257:/usr/lib/avr/include/stdlib.h **** 
 258:/usr/lib/avr/include/stdlib.h ****     this function does not detect overflow (\c errno is not changed and
 259:/usr/lib/avr/include/stdlib.h ****     the result value is not predictable), uses smaller memory (flash and
 260:/usr/lib/avr/include/stdlib.h ****     stack) and works more quickly.
 261:/usr/lib/avr/include/stdlib.h **** */
 262:/usr/lib/avr/include/stdlib.h **** extern long atol(const char *__s) __ATTR_PURE__;
 263:/usr/lib/avr/include/stdlib.h **** 
 264:/usr/lib/avr/include/stdlib.h **** /**
 265:/usr/lib/avr/include/stdlib.h ****     The atoi() function converts the initial portion of the string
 266:/usr/lib/avr/include/stdlib.h ****     pointed to by \p s to integer representation. In contrast to
 267:/usr/lib/avr/include/stdlib.h **** 
 268:/usr/lib/avr/include/stdlib.h ****         \code (int)strtol(s, (char **)NULL, 10); \endcode
 269:/usr/lib/avr/include/stdlib.h **** 
 270:/usr/lib/avr/include/stdlib.h ****     this function does not detect overflow (\c errno is not changed and
 271:/usr/lib/avr/include/stdlib.h ****     the result value is not predictable), uses smaller memory (flash and
 272:/usr/lib/avr/include/stdlib.h ****     stack) and works more quickly.
 273:/usr/lib/avr/include/stdlib.h **** */
 274:/usr/lib/avr/include/stdlib.h **** extern int atoi(const char *__s) __ATTR_PURE__;
 275:/usr/lib/avr/include/stdlib.h **** 
 276:/usr/lib/avr/include/stdlib.h **** /**
 277:/usr/lib/avr/include/stdlib.h ****    The exit() function terminates the application.  Since there is no
 278:/usr/lib/avr/include/stdlib.h ****    environment to return to, \c status is ignored, and code execution
 279:/usr/lib/avr/include/stdlib.h ****    will eventually reach an infinite loop, thereby effectively halting
 280:/usr/lib/avr/include/stdlib.h ****    all code processing.  Before entering the infinite loop, interrupts
 281:/usr/lib/avr/include/stdlib.h ****    are globally disabled.
 282:/usr/lib/avr/include/stdlib.h **** 
 283:/usr/lib/avr/include/stdlib.h ****    In a C++ context, global destructors will be called before halting
 284:/usr/lib/avr/include/stdlib.h ****    execution.
 285:/usr/lib/avr/include/stdlib.h **** */
 286:/usr/lib/avr/include/stdlib.h **** extern void exit(int __status) __ATTR_NORETURN__;
 287:/usr/lib/avr/include/stdlib.h **** 
 288:/usr/lib/avr/include/stdlib.h **** /**
 289:/usr/lib/avr/include/stdlib.h ****    The malloc() function allocates \c size bytes of memory.
 290:/usr/lib/avr/include/stdlib.h ****    If malloc() fails, a NULL pointer is returned.
 291:/usr/lib/avr/include/stdlib.h **** 
 292:/usr/lib/avr/include/stdlib.h ****    Note that malloc() does \e not initialize the returned memory to
 293:/usr/lib/avr/include/stdlib.h ****    zero bytes.
 294:/usr/lib/avr/include/stdlib.h **** 
 295:/usr/lib/avr/include/stdlib.h ****    See the chapter about \ref malloc "malloc() usage" for implementation
 296:/usr/lib/avr/include/stdlib.h ****    details.
 297:/usr/lib/avr/include/stdlib.h **** */
 298:/usr/lib/avr/include/stdlib.h **** extern void *malloc(size_t __size) __ATTR_MALLOC__;
 299:/usr/lib/avr/include/stdlib.h **** 
 300:/usr/lib/avr/include/stdlib.h **** /**
 301:/usr/lib/avr/include/stdlib.h ****    The free() function causes the allocated memory referenced by \c
 302:/usr/lib/avr/include/stdlib.h ****    ptr to be made available for future allocations.  If \c ptr is
 303:/usr/lib/avr/include/stdlib.h ****    NULL, no action occurs.
 304:/usr/lib/avr/include/stdlib.h **** */
 305:/usr/lib/avr/include/stdlib.h **** extern void free(void *__ptr);
 306:/usr/lib/avr/include/stdlib.h **** 
 307:/usr/lib/avr/include/stdlib.h **** /**
 308:/usr/lib/avr/include/stdlib.h ****    \c malloc() \ref malloc_tunables "tunable".
 309:/usr/lib/avr/include/stdlib.h **** */
 310:/usr/lib/avr/include/stdlib.h **** extern size_t __malloc_margin;
 311:/usr/lib/avr/include/stdlib.h **** 
 312:/usr/lib/avr/include/stdlib.h **** /**
 313:/usr/lib/avr/include/stdlib.h ****    \c malloc() \ref malloc_tunables "tunable".
 314:/usr/lib/avr/include/stdlib.h **** */
 315:/usr/lib/avr/include/stdlib.h **** extern char *__malloc_heap_start;
 316:/usr/lib/avr/include/stdlib.h **** 
 317:/usr/lib/avr/include/stdlib.h **** /**
 318:/usr/lib/avr/include/stdlib.h ****    \c malloc() \ref malloc_tunables "tunable".
 319:/usr/lib/avr/include/stdlib.h **** */
 320:/usr/lib/avr/include/stdlib.h **** extern char *__malloc_heap_end;
 321:/usr/lib/avr/include/stdlib.h **** 
 322:/usr/lib/avr/include/stdlib.h **** /**
 323:/usr/lib/avr/include/stdlib.h ****    Allocate \c nele elements of \c size each.  Identical to calling
 324:/usr/lib/avr/include/stdlib.h ****    \c malloc() using <tt>nele * size</tt> as argument, except the
 325:/usr/lib/avr/include/stdlib.h ****    allocated memory will be cleared to zero.
 326:/usr/lib/avr/include/stdlib.h **** */
 327:/usr/lib/avr/include/stdlib.h **** extern void *calloc(size_t __nele, size_t __size) __ATTR_MALLOC__;
 328:/usr/lib/avr/include/stdlib.h **** 
 329:/usr/lib/avr/include/stdlib.h **** /**
 330:/usr/lib/avr/include/stdlib.h ****    The realloc() function tries to change the size of the region
 331:/usr/lib/avr/include/stdlib.h ****    allocated at \c ptr to the new \c size value.  It returns a
 332:/usr/lib/avr/include/stdlib.h ****    pointer to the new region.  The returned pointer might be the
 333:/usr/lib/avr/include/stdlib.h ****    same as the old pointer, or a pointer to a completely different
 334:/usr/lib/avr/include/stdlib.h ****    region.
 335:/usr/lib/avr/include/stdlib.h **** 
 336:/usr/lib/avr/include/stdlib.h ****    The contents of the returned region up to either the old or the new
 337:/usr/lib/avr/include/stdlib.h ****    size value (whatever is less) will be identical to the contents of
 338:/usr/lib/avr/include/stdlib.h ****    the old region, even in case a new region had to be allocated.
 339:/usr/lib/avr/include/stdlib.h **** 
 340:/usr/lib/avr/include/stdlib.h ****    It is acceptable to pass \c ptr as NULL, in which case realloc()
 341:/usr/lib/avr/include/stdlib.h ****    will behave identical to malloc().
 342:/usr/lib/avr/include/stdlib.h **** 
 343:/usr/lib/avr/include/stdlib.h ****    If the new memory cannot be allocated, realloc() returns NULL, and
 344:/usr/lib/avr/include/stdlib.h ****    the region at \c ptr will not be changed.
 345:/usr/lib/avr/include/stdlib.h **** */
 346:/usr/lib/avr/include/stdlib.h **** extern void *realloc(void *__ptr, size_t __size) __ATTR_MALLOC__;
 347:/usr/lib/avr/include/stdlib.h **** 
 348:/usr/lib/avr/include/stdlib.h **** extern double strtod(const char *__nptr, char **__endptr);
 349:/usr/lib/avr/include/stdlib.h **** 
 350:/usr/lib/avr/include/stdlib.h **** extern double atof(const char *__nptr);
 351:/usr/lib/avr/include/stdlib.h **** 
 352:/usr/lib/avr/include/stdlib.h **** /** Highest number that can be generated by rand(). */
 353:/usr/lib/avr/include/stdlib.h **** #define	RAND_MAX 0x7FFF
 354:/usr/lib/avr/include/stdlib.h **** 
 355:/usr/lib/avr/include/stdlib.h **** /**
 356:/usr/lib/avr/include/stdlib.h ****      The rand() function computes a sequence of pseudo-random integers in the
 357:/usr/lib/avr/include/stdlib.h ****      range of 0 to \c RAND_MAX (as defined by the header file <stdlib.h>).
 358:/usr/lib/avr/include/stdlib.h **** 
 359:/usr/lib/avr/include/stdlib.h ****      The srand() function sets its argument \c seed as the seed for a new
 360:/usr/lib/avr/include/stdlib.h ****      sequence of pseudo-random numbers to be returned by rand().  These
 361:/usr/lib/avr/include/stdlib.h ****      sequences are repeatable by calling srand() with the same seed value.
 362:/usr/lib/avr/include/stdlib.h **** 
 363:/usr/lib/avr/include/stdlib.h ****      If no seed value is provided, the functions are automatically seeded with
 364:/usr/lib/avr/include/stdlib.h ****      a value of 1.
 365:/usr/lib/avr/include/stdlib.h **** 
 366:/usr/lib/avr/include/stdlib.h ****      In compliance with the C standard, these functions operate on
 367:/usr/lib/avr/include/stdlib.h ****      \c int arguments.  Since the underlying algorithm already uses
 368:/usr/lib/avr/include/stdlib.h ****      32-bit calculations, this causes a loss of precision.  See
 369:/usr/lib/avr/include/stdlib.h ****      \c random() for an alternate set of functions that retains full
 370:/usr/lib/avr/include/stdlib.h ****      32-bit precision.
 371:/usr/lib/avr/include/stdlib.h **** */
 372:/usr/lib/avr/include/stdlib.h **** extern int rand(void);
 373:/usr/lib/avr/include/stdlib.h **** /**
 374:/usr/lib/avr/include/stdlib.h ****    Pseudo-random number generator seeding; see rand().
 375:/usr/lib/avr/include/stdlib.h **** */
 376:/usr/lib/avr/include/stdlib.h **** extern void srand(unsigned int __seed);
 377:/usr/lib/avr/include/stdlib.h **** 
 378:/usr/lib/avr/include/stdlib.h **** /**
 379:/usr/lib/avr/include/stdlib.h ****    Variant of rand() that stores the context in the user-supplied
 380:/usr/lib/avr/include/stdlib.h ****    variable located at \c ctx instead of a static library variable
 381:/usr/lib/avr/include/stdlib.h ****    so the function becomes re-entrant.
 382:/usr/lib/avr/include/stdlib.h **** */
 383:/usr/lib/avr/include/stdlib.h **** extern int rand_r(unsigned long *__ctx);
 384:/usr/lib/avr/include/stdlib.h **** /*@}*/
 385:/usr/lib/avr/include/stdlib.h **** 
 386:/usr/lib/avr/include/stdlib.h **** /*@{*/
 387:/usr/lib/avr/include/stdlib.h **** /** \name Non-standard (i.e. non-ISO C) functions.
 388:/usr/lib/avr/include/stdlib.h ****  \ingroup avr_stdlib
 389:/usr/lib/avr/include/stdlib.h **** */
 390:/usr/lib/avr/include/stdlib.h **** /**
 391:/usr/lib/avr/include/stdlib.h ****    \brief Convert an integer to a string.
 392:/usr/lib/avr/include/stdlib.h **** 
 393:/usr/lib/avr/include/stdlib.h ****    The function itoa() converts the integer value from \c val into an
 394:/usr/lib/avr/include/stdlib.h ****    ASCII representation that will be stored under \c s.  The caller
 395:/usr/lib/avr/include/stdlib.h ****    is responsible for providing sufficient storage in \c s.
 396:/usr/lib/avr/include/stdlib.h **** 
 397:/usr/lib/avr/include/stdlib.h ****    \note The minimal size of the buffer \c s depends on the choice of
 398:/usr/lib/avr/include/stdlib.h ****    radix. For example, if the radix is 2 (binary), you need to supply a buffer
 399:/usr/lib/avr/include/stdlib.h ****    with a minimal length of 8 * sizeof (int) + 1 characters, i.e. one
 400:/usr/lib/avr/include/stdlib.h ****    character for each bit plus one for the string terminator. Using a larger
 401:/usr/lib/avr/include/stdlib.h ****    radix will require a smaller minimal buffer size.
 402:/usr/lib/avr/include/stdlib.h **** 
 403:/usr/lib/avr/include/stdlib.h ****    \warning If the buffer is too small, you risk a buffer overflow.
 404:/usr/lib/avr/include/stdlib.h **** 
 405:/usr/lib/avr/include/stdlib.h ****    Conversion is done using the \c radix as base, which may be a
 406:/usr/lib/avr/include/stdlib.h ****    number between 2 (binary conversion) and up to 36.  If \c radix
 407:/usr/lib/avr/include/stdlib.h ****    is greater than 10, the next digit after \c '9' will be the letter
 408:/usr/lib/avr/include/stdlib.h ****    \c 'a'.
 409:/usr/lib/avr/include/stdlib.h ****     
 410:/usr/lib/avr/include/stdlib.h ****     If radix is 10 and val is negative, a minus sign will be prepended.
 411:/usr/lib/avr/include/stdlib.h **** 
 412:/usr/lib/avr/include/stdlib.h ****    The itoa() function returns the pointer passed as \c s.
 413:/usr/lib/avr/include/stdlib.h **** */
 414:/usr/lib/avr/include/stdlib.h **** #ifdef  __DOXYGEN__
 415:/usr/lib/avr/include/stdlib.h **** extern char *itoa(int val, char *s, int radix);
 416:/usr/lib/avr/include/stdlib.h **** #else
 417:/usr/lib/avr/include/stdlib.h **** extern __inline__ __ATTR_GNU_INLINE__
 418:/usr/lib/avr/include/stdlib.h **** char *itoa (int __val, char *__s, int __radix)
 419:/usr/lib/avr/include/stdlib.h **** {
 420:/usr/lib/avr/include/stdlib.h ****     if (!__builtin_constant_p (__radix)) {
 421:/usr/lib/avr/include/stdlib.h **** 	extern char *__itoa (int, char *, int);
 422:/usr/lib/avr/include/stdlib.h **** 	return __itoa (__val, __s, __radix);
 423:/usr/lib/avr/include/stdlib.h ****     } else if (__radix < 2 || __radix > 36) {
 424:/usr/lib/avr/include/stdlib.h **** 	*__s = 0;
 425:/usr/lib/avr/include/stdlib.h **** 	return __s;
 426:/usr/lib/avr/include/stdlib.h ****     } else {
 427:/usr/lib/avr/include/stdlib.h **** 	extern char *__itoa_ncheck (int, char *, unsigned char);
 428:/usr/lib/avr/include/stdlib.h **** 	return __itoa_ncheck (__val, __s, __radix);
 1063               		.loc 3 428 0
 1064 036c 4AE0      		ldi r20,lo8(10)
 1065 036e BE01      		movw r22,r28
 1066 0370 6F5F      		subi r22,-1
 1067 0372 7F4F      		sbci r23,-1
 1068 0374 0E94 0000 		call __itoa_ncheck
 1069               	.LVL109:
 1070               	.LBE49:
 1071               	.LBE48:
 365:./lcd.h       **** 	char str[6];
 366:./lcd.h       **** 	itoa( num, str, 10 );
 367:./lcd.h       **** 	lcd_puts( str );
 1072               		.loc 1 367 0
 1073 0378 CE01      		movw r24,r28
 1074 037a 0196      		adiw r24,1
 1075 037c 0E94 0000 		call lcd_puts
 1076               	.LVL110:
 1077               	/* epilogue start */
 368:./lcd.h       **** }
 1078               		.loc 1 368 0
 1079 0380 2696      		adiw r28,6
 1080               	.LVL111:
 1081 0382 0FB6      		in __tmp_reg__,__SREG__
 1082 0384 F894      		cli
 1083 0386 DEBF      		out __SP_H__,r29
 1084 0388 0FBE      		out __SREG__,__tmp_reg__
 1085 038a CDBF      		out __SP_L__,r28
 1086               	.LVL112:
 1087 038c DF91      		pop r29
 1088 038e CF91      		pop r28
 1089 0390 0895      		ret
 1090               		.cfi_endproc
 1091               	.LFE24:
 1093               	.global	lcd_gotoxy
 1095               	lcd_gotoxy:
 1096               	.LFB25:
 369:./lcd.h       **** 
 370:./lcd.h       **** void lcd_gotoxy( unsigned char x, unsigned char y )
 371:./lcd.h       **** {
 1097               		.loc 1 371 0
 1098               		.cfi_startproc
 1099               	.LVL113:
 1100               	/* prologue: function */
 1101               	/* frame size = 0 */
 1102               	/* stack size = 0 */
 1103               	.L__stack_usage = 0
 372:./lcd.h       **** 	lcd_goto( y*64+x );
 1104               		.loc 1 372 0
 1105 0392 90E4      		ldi r25,lo8(64)
 1106 0394 699F      		mul r22,r25
 1107 0396 800D      		add r24,r0
 1108 0398 1124      		clr __zero_reg__
 1109               	.LVL114:
 1110 039a 0C94 0000 		jmp lcd_goto
 1111               	.LVL115:
 1112               		.cfi_endproc
 1113               	.LFE25:
 1115               	.global	Printf
 1117               	Printf:
 1118               	.LFB26:
 373:./lcd.h       **** }
 374:./lcd.h       **** 
 375:./lcd.h       **** void Printf( char *fmt,... )
 376:./lcd.h       **** {
 1119               		.loc 1 376 0
 1120               		.cfi_startproc
 1121               	.LVL116:
 1122 039e CF92      		push r12
 1123               	.LCFI21:
 1124               		.cfi_def_cfa_offset 3
 1125               		.cfi_offset 12, -2
 1126 03a0 DF92      		push r13
 1127               	.LCFI22:
 1128               		.cfi_def_cfa_offset 4
 1129               		.cfi_offset 13, -3
 1130 03a2 EF92      		push r14
 1131               	.LCFI23:
 1132               		.cfi_def_cfa_offset 5
 1133               		.cfi_offset 14, -4
 1134 03a4 FF92      		push r15
 1135               	.LCFI24:
 1136               		.cfi_def_cfa_offset 6
 1137               		.cfi_offset 15, -5
 1138 03a6 0F93      		push r16
 1139               	.LCFI25:
 1140               		.cfi_def_cfa_offset 7
 1141               		.cfi_offset 16, -6
 1142 03a8 1F93      		push r17
 1143               	.LCFI26:
 1144               		.cfi_def_cfa_offset 8
 1145               		.cfi_offset 17, -7
 1146 03aa CF93      		push r28
 1147               	.LCFI27:
 1148               		.cfi_def_cfa_offset 9
 1149               		.cfi_offset 28, -8
 1150 03ac DF93      		push r29
 1151               	.LCFI28:
 1152               		.cfi_def_cfa_offset 10
 1153               		.cfi_offset 29, -9
 1154 03ae CDB7      		in r28,__SP_L__
 1155 03b0 DEB7      		in r29,__SP_H__
 1156               	.LCFI29:
 1157               		.cfi_def_cfa_register 28
 1158               	/* prologue: function */
 1159               	/* frame size = 0 */
 1160               	/* stack size = 8 */
 1161               	.L__stack_usage = 8
 1162 03b2 FE01      		movw r30,r28
 1163 03b4 3B96      		adiw r30,11
 1164 03b6 E190      		ld r14,Z+
 1165 03b8 F190      		ld r15,Z+
 377:./lcd.h       **** 	va_list aptr;
 378:./lcd.h       **** 	char *p, *sval, str[17],ch;
 379:./lcd.h       **** 	int ival;
 380:./lcd.h       **** 	va_start( aptr, fmt );
 1166               		.loc 1 380 0
 1167 03ba 8F01      		movw r16,r30
 1168               	.LVL117:
 1169               	.L58:
 381:./lcd.h       **** 
 382:./lcd.h       **** 	for( p=fmt; *p ; ++p )
 1170               		.loc 1 382 0 discriminator 1
 1171 03bc F701      		movw r30,r14
 1172 03be 8081      		ld r24,Z
 1173 03c0 8823      		tst r24
 1174 03c2 01F0      		breq .L68
 383:./lcd.h       **** 	if( *p=='%' )
 1175               		.loc 1 383 0
 1176 03c4 8532      		cpi r24,lo8(37)
 1177 03c6 01F4      		brne .L59
 384:./lcd.h       **** 	switch( * ++p )
 1178               		.loc 1 384 0
 1179 03c8 6701      		movw r12,r14
 1180 03ca 8FEF      		ldi r24,-1
 1181 03cc C81A      		sub r12,r24
 1182 03ce D80A      		sbc r13,r24
 1183               	.LVL118:
 1184 03d0 F701      		movw r30,r14
 1185 03d2 8181      		ldd r24,Z+1
 1186 03d4 8436      		cpi r24,lo8(100)
 1187 03d6 01F0      		breq .L61
 1188 03d8 8337      		cpi r24,lo8(115)
 1189 03da 01F4      		brne .L69
 385:./lcd.h       **** 	{
 386:./lcd.h       **** 		case 'd':
 387:./lcd.h       **** 		ival = va_arg( aptr, int );
 388:./lcd.h       **** 		lcd_num( ival );
 389:./lcd.h       **** 		break;
 390:./lcd.h       **** 
 391:./lcd.h       **** 		case 's':
 392:./lcd.h       **** 		for( sval=va_arg(aptr, char*); *sval; ++sval )
 1190               		.loc 1 392 0
 1191 03dc F801      		movw r30,r16
 1192 03de E080      		ld r14,Z
 1193 03e0 F180      		ldd r15,Z+1
 1194 03e2 0E5F      		subi r16,-2
 1195 03e4 1F4F      		sbci r17,-1
 1196               	.LVL119:
 1197 03e6 00C0      		rjmp .L64
 1198               	.LVL120:
 1199               	.L61:
 387:./lcd.h       **** 		lcd_num( ival );
 1200               		.loc 1 387 0
 1201 03e8 7801      		movw r14,r16
 1202 03ea F2E0      		ldi r31,2
 1203 03ec EF0E      		add r14,r31
 1204 03ee F11C      		adc r15,__zero_reg__
 1205               	.LVL121:
 388:./lcd.h       **** 		break;
 1206               		.loc 1 388 0
 1207 03f0 F801      		movw r30,r16
 1208 03f2 8081      		ld r24,Z
 1209 03f4 9181      		ldd r25,Z+1
 1210 03f6 0E94 0000 		call lcd_num
 1211               	.LVL122:
 387:./lcd.h       **** 		lcd_num( ival );
 1212               		.loc 1 387 0
 1213 03fa 8701      		movw r16,r14
 389:./lcd.h       **** 
 1214               		.loc 1 389 0
 1215 03fc 00C0      		rjmp .L63
 1216               	.LVL123:
 1217               	.L64:
 1218               		.loc 1 392 0 discriminator 1
 1219 03fe F701      		movw r30,r14
 1220 0400 8191      		ld r24,Z+
 1221 0402 7F01      		movw r14,r30
 1222               	.LVL124:
 1223 0404 8823      		tst r24
 1224 0406 01F0      		breq .L63
 393:./lcd.h       **** 		lcd_putch( *sval );
 1225               		.loc 1 393 0 discriminator 3
 1226 0408 0E94 0000 		call lcd_putch
 1227               	.LVL125:
 1228 040c 00C0      		rjmp .L64
 1229               	.LVL126:
 1230               	.L69:
 394:./lcd.h       **** 		break;
 395:./lcd.h       **** 
 396:./lcd.h       **** 
 397:./lcd.h       **** 		default:
 398:./lcd.h       **** 		lcd_putch(*p);
 1231               		.loc 1 398 0
 1232 040e 0E94 0000 		call lcd_putch
 1233               	.LVL127:
 1234 0412 00C0      		rjmp .L63
 1235               	.LVL128:
 1236               	.L59:
 399:./lcd.h       **** 
 400:./lcd.h       **** 
 401:./lcd.h       **** 	}
 402:./lcd.h       **** 	else
 403:./lcd.h       **** 	lcd_putch( *p );
 1237               		.loc 1 403 0
 1238 0414 0E94 0000 		call lcd_putch
 1239               	.LVL129:
 1240 0418 6701      		movw r12,r14
 1241               	.LVL130:
 1242               	.L63:
 382:./lcd.h       **** 	if( *p=='%' )
 1243               		.loc 1 382 0 discriminator 2
 1244 041a 7601      		movw r14,r12
 1245 041c FFEF      		ldi r31,-1
 1246 041e EF1A      		sub r14,r31
 1247 0420 FF0A      		sbc r15,r31
 1248               	.LVL131:
 1249 0422 00C0      		rjmp .L58
 1250               	.L68:
 1251               	/* epilogue start */
 404:./lcd.h       **** }
 1252               		.loc 1 404 0
 1253 0424 DF91      		pop r29
 1254 0426 CF91      		pop r28
 1255 0428 1F91      		pop r17
 1256 042a 0F91      		pop r16
 1257               	.LVL132:
 1258 042c FF90      		pop r15
 1259 042e EF90      		pop r14
 1260               	.LVL133:
 1261 0430 DF90      		pop r13
 1262 0432 CF90      		pop r12
 1263 0434 0895      		ret
 1264               		.cfi_endproc
 1265               	.LFE26:
 1267               		.section	.rodata.str1.1,"aMS",@progbits,1
 1268               	.LC0:
 1269 0000 4865 6C6C 		.string	"Hello"
 1269      6F00 
 1270               		.section	.text.startup,"ax",@progbits
 1271               	.global	main
 1273               	main:
 1274               	.LFB27:
 1275               		.file 4 "program.c"
   1:program.c     **** #define F_CPU 16000000UL
   2:program.c     **** #include<avr/io.h>
   3:program.c     **** #include<util/delay.h>
   4:program.c     **** #include<lcd.h>
   5:program.c     **** #include<uart.h>
   6:program.c     **** 
   7:program.c     **** int main()
   8:program.c     **** {
 1276               		.loc 4 8 0
 1277               		.cfi_startproc
 1278               	/* prologue: function */
 1279               	/* frame size = 0 */
 1280               	/* stack size = 0 */
 1281               	.L__stack_usage = 0
   9:program.c     ****   uart0_init(UART_BAUD_SELECT(9600,F_CPU));
 1282               		.loc 4 9 0
 1283 0000 87E6      		ldi r24,lo8(103)
 1284 0002 90E0      		ldi r25,0
 1285 0004 0E94 0000 		call uart0_init
 1286               	.LVL134:
  10:program.c     ****   lcd_init();
 1287               		.loc 4 10 0
 1288 0008 0E94 0000 		call lcd_init
 1289               	.LVL135:
  11:program.c     **** 
  12:program.c     **** //  while(1)
  13:program.c     ****   lcd_num(6);
 1290               		.loc 4 13 0
 1291 000c 86E0      		ldi r24,lo8(6)
 1292 000e 90E0      		ldi r25,0
 1293 0010 0E94 0000 		call lcd_num
 1294               	.LVL136:
 1295               	.LBB56:
 1296               	.LBB57:
 163:/usr/lib/avr/include/util/delay.h **** 
 1297               		.loc 2 163 0
 1298 0014 2FEF      		ldi r18,lo8(639999)
 1299 0016 83EC      		ldi r24,hi8(639999)
 1300 0018 99E0      		ldi r25,hlo8(639999)
 1301 001a 2150      	1:	subi r18,1
 1302 001c 8040      		sbci r24,0
 1303 001e 9040      		sbci r25,0
 1304 0020 01F4      		brne 1b
 1305 0022 00C0      		rjmp .
 1306 0024 0000      		nop
 1307               	.LVL137:
 1308               	.LBE57:
 1309               	.LBE56:
 1310               	.LBB58:
 1311               	.LBB59:
 372:./lcd.h       **** }
 1312               		.loc 1 372 0
 1313 0026 80E4      		ldi r24,lo8(64)
 1314 0028 0E94 0000 		call lcd_goto
 1315               	.LVL138:
 1316               	.LBE59:
 1317               	.LBE58:
  14:program.c     ****   _delay_ms(200);
  15:program.c     **** 
  16:program.c     **** //  lcd_num(5);
  17:program.c     **** //  _delay_ms(200);
  18:program.c     **** lcd_gotoxy(0,5);
  19:program.c     **** Printf("Hello");
 1318               		.loc 4 19 0
 1319 002c 80E0      		ldi r24,lo8(.LC0)
 1320 002e 90E0      		ldi r25,hi8(.LC0)
 1321 0030 9F93      		push r25
 1322               	.LCFI30:
 1323               		.cfi_def_cfa_offset 3
 1324 0032 8F93      		push r24
 1325               	.LCFI31:
 1326               		.cfi_def_cfa_offset 4
 1327 0034 0E94 0000 		call Printf
 1328               	.LVL139:
 1329               	.LBB60:
 1330               	.LBB61:
 163:/usr/lib/avr/include/util/delay.h **** 
 1331               		.loc 2 163 0
 1332 0038 2FEF      		ldi r18,lo8(639999)
 1333 003a 83EC      		ldi r24,hi8(639999)
 1334 003c 99E0      		ldi r25,hlo8(639999)
 1335 003e 2150      	1:	subi r18,1
 1336 0040 8040      		sbci r24,0
 1337 0042 9040      		sbci r25,0
 1338 0044 01F4      		brne 1b
 1339 0046 00C0      		rjmp .
 1340 0048 0000      		nop
 1341               	.LBE61:
 1342               	.LBE60:
  20:program.c     **** _delay_ms(200);
  21:program.c     **** lcd_clear();
 1343               		.loc 4 21 0
 1344 004a 0E94 0000 		call lcd_clear
 1345               	.LVL140:
 1346 004e 0F90      		pop __tmp_reg__
 1347 0050 0F90      		pop __tmp_reg__
 1348               	.LCFI32:
 1349               		.cfi_def_cfa_offset 2
  22:program.c     **** 
  23:program.c     **** 
  24:program.c     **** }
 1350               		.loc 4 24 0
 1351 0052 80E0      		ldi r24,0
 1352 0054 90E0      		ldi r25,0
 1353 0056 0895      		ret
 1354               		.cfi_endproc
 1355               	.LFE27:
 1357               	.global	chex_wBlanking
 1358               		.section	.progmem.data,"a",@progbits
 1361               	chex_wBlanking:
 1362 0000 20        		.byte	32
 1363 0001 31        		.byte	49
 1364 0002 32        		.byte	50
 1365 0003 33        		.byte	51
 1366 0004 34        		.byte	52
 1367 0005 35        		.byte	53
 1368 0006 36        		.byte	54
 1369 0007 37        		.byte	55
 1370 0008 38        		.byte	56
 1371 0009 39        		.byte	57
 1372 000a 41        		.byte	65
 1373 000b 42        		.byte	66
 1374 000c 43        		.byte	67
 1375 000d 44        		.byte	68
 1376 000e 45        		.byte	69
 1377 000f 46        		.byte	70
 1378               	.global	chex
 1381               	chex:
 1382 0010 30        		.byte	48
 1383 0011 31        		.byte	49
 1384 0012 32        		.byte	50
 1385 0013 33        		.byte	51
 1386 0014 34        		.byte	52
 1387 0015 35        		.byte	53
 1388 0016 36        		.byte	54
 1389 0017 37        		.byte	55
 1390 0018 38        		.byte	56
 1391 0019 39        		.byte	57
 1392 001a 41        		.byte	65
 1393 001b 42        		.byte	66
 1394 001c 43        		.byte	67
 1395 001d 44        		.byte	68
 1396 001e 45        		.byte	69
 1397 001f 46        		.byte	70
 1398               		.text
 1399               	.Letext0:
 1400               		.file 5 "/usr/lib/avr/include/stdint.h"
 1401               		.file 6 "/usr/lib/gcc/avr/4.9.2/include/stdarg.h"
 1402               		.file 7 "./uart.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 program.c
     /tmp/ccnKbbCB.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccnKbbCB.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccnKbbCB.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccnKbbCB.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccnKbbCB.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccnKbbCB.s:11     .text:0000000000000000 lcd_write
     /tmp/ccnKbbCB.s:123    .text:0000000000000062 lcd_cmd
     /tmp/ccnKbbCB.s:142    .text:0000000000000068 lcd_dat
     /tmp/ccnKbbCB.s:161    .text:000000000000006e lcd_clear
     /tmp/ccnKbbCB.s:192    .text:0000000000000084 lcd_puts
     /tmp/ccnKbbCB.s:237    .text:000000000000009e lcd_puts_p
     /tmp/ccnKbbCB.s:292    .text:00000000000000be lcd_putch
     /tmp/ccnKbbCB.s:311    .text:00000000000000c4 lcd_goto
     /tmp/ccnKbbCB.s:332    .text:00000000000000cc lcd_init
     /tmp/ccnKbbCB.s:452    .text:0000000000000142 lcd_unum_hex
     /tmp/ccnKbbCB.s:1381   .progmem.data:0000000000000010 chex
     /tmp/ccnKbbCB.s:564    .text:000000000000019c lcd_unum_hex_wBlanking
     /tmp/ccnKbbCB.s:1361   .progmem.data:0000000000000000 chex_wBlanking
     /tmp/ccnKbbCB.s:676    .text:00000000000001f6 lcd_unum3
     /tmp/ccnKbbCB.s:748    .text:0000000000000240 lcd_unum
     /tmp/ccnKbbCB.s:1033   .text:000000000000035e lcd_num
     /tmp/ccnKbbCB.s:1095   .text:0000000000000392 lcd_gotoxy
     /tmp/ccnKbbCB.s:1117   .text:000000000000039e Printf
     /tmp/ccnKbbCB.s:1273   .text.startup:0000000000000000 main

UNDEFINED SYMBOLS
__udivmodqi4
__itoa_ncheck
uart0_init
__do_copy_data
